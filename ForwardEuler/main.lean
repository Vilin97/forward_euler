/-
We implement the explicit Euler method for ODEs and prove its convergence.

Definitions:
- `eulerStep`: A single step of the Euler method.
- `eulerPoint`: The sequence of points generated by the Euler method.
- `eulerPath`: The piecewise linear interpolation of the Euler points.
- `eulerDeriv`: The right derivative of the Euler path.

Theorems:
- `eulerPath_grid_point`: The Euler path coincides with the Euler points at grid points.
- `eulerPath_continuous`: The Euler path is continuous.
- `eulerPath_hasDerivWithinAt`: The Euler path has the expected right derivative.
- `eulerPath_eq_on_Ico`: Explicit formula for the Euler path on intervals.
- `eulerDeriv_eq_on_Ico`: Explicit formula for the Euler derivative on intervals.
- `euler_derivative_global_bound`: Global bound on the difference between the Euler derivative and the vector field.
- `euler_error_bound`: Error bound for the Euler method using Gronwall's inequality.
- `euler_convergence`: The Euler method converges to the true solution as the step size goes to zero.
-/

import Mathlib.Analysis.ODE.Gronwall

set_option linter.mathlibStandardSet false

private theorem floor_eq_of_mem_Ico {h : â„} (h_pos : 0 < h) {a : â„} {n : â„•} {t : â„}
    (ht : t âˆˆ Set.Ico (a + n * h) (a + (n + 1) * h)) :
    âŒŠ(t - a) / hâŒ‹â‚Š = n :=
  by refine Nat.floor_eq_on_Ico n _ âŸ¨?_, ?_âŸ© <;>
     (first | rw [le_div_iffâ‚€ h_pos] | rw [div_lt_iffâ‚€ h_pos]) <;> grind

private theorem mem_Ico_floor {h : â„} (h_pos : 0 < h) {a t : â„} (ht : a â‰¤ t) :
    t âˆˆ Set.Ico (a + âŒŠ(t - a) / hâŒ‹â‚Š * h) (a + (â†‘âŒŠ(t - a) / hâŒ‹â‚Š + 1) * h) :=
  by constructor <;> nlinarith [Nat.floor_le (div_nonneg (sub_nonneg.mpr ht) h_pos.le),
      Nat.lt_floor_add_one ((t - a) / h), mul_div_cancelâ‚€ (t - a) h_pos.ne']

/-- A function continuous on each cell `[a + n*h, a + (n+1)*h]` is continuous on `[a, âˆ)`. -/
theorem continuousOn_Ici_of_Icc_grid {E : Type*} [TopologicalSpace E] {f : â„ â†’ E}
    {h : â„} (h_pos : 0 < h) {a : â„}
    (hf : âˆ€ n : â„•, ContinuousOn f (Set.Icc (a + n * h) (a + (n + 1) * h))) :
    ContinuousOn f (Set.Ici a) := by
  have h_lf : LocallyFinite fun n : â„• => Set.Icc (a + n * h) (a + (â†‘n + 1) * h) := by
    intro x; refine âŸ¨Set.Ioo (x - h) (x + h), Ioo_mem_nhds (by linarith) (by linarith),
      (Set.finite_Icc (âŒŠ(x - h - a) / hâŒ‹â‚Š) (âŒˆ(x + h - a) / hâŒ‰â‚Š)).subset ?_âŸ©
    rintro n âŸ¨z, âŸ¨hz1, hz2âŸ©, hz3, hz4âŸ©
    refine âŸ¨Nat.lt_add_one_iff.mp ((Nat.floor_lt' (by linarith)).mpr ?_),
           Nat.cast_le.mp ((?_ : (n : â„) â‰¤ _).trans (Nat.le_ceil _))âŸ© <;>
    (first | rw [div_lt_iffâ‚€ h_pos] | rw [le_div_iffâ‚€ h_pos]) <;> grind
  exact (h_lf.continuousOn_iUnion (fun n => isClosed_Icc) (hf Â·)).mono fun t (ht : a â‰¤ t) =>
    Set.mem_iUnion.mpr âŸ¨_, Set.Ico_subset_Icc_self (mem_Ico_floor h_pos ht)âŸ©

/--
The Euler step for an ODE y' = v(t, y) with step size h is y_{n+1} = y_n + h * v(t_n, y_n).
-/
def eulerStep {ğ•œ : Type*} {E : Type*} [Ring ğ•œ] [AddCommGroup E] [Module ğ•œ E] (v : ğ•œ â†’ E â†’ E) (h : ğ•œ) (t : ğ•œ) (y : E) : E :=
  y + h â€¢ v t y

/--
The n-th point in the Euler method approximation with step size h.
-/
def eulerPoint {ğ•œ : Type*} {E : Type*} [Ring ğ•œ] [AddCommGroup E] [Module ğ•œ E] (v : ğ•œ â†’ E â†’ E) (h : ğ•œ) (t0 : ğ•œ) (y0 : E) : â„• â†’ E
| 0 => y0
| n + 1 => eulerStep v h (t0 + n * h) (eulerPoint v h t0 y0 n)

/--
The piecewise linear path interpolating the Euler method points.
-/
noncomputable def eulerPath {ğ•œ : Type*} {E : Type*} [Field ğ•œ] [PartialOrder ğ•œ] [FloorSemiring ğ•œ]
    [AddCommGroup E] [Module ğ•œ E]
  (v : ğ•œ â†’ E â†’ E) (h : ğ•œ) (t0 : ğ•œ) (y0 : E) (t : ğ•œ) : E :=
  let n := Nat.floor ((t - t0) / h)
  let tn := t0 + n * h
  let yn := eulerPoint v h t0 y0 n
  yn + (t - tn) â€¢ v tn yn

/--
The derivative of the Euler path (defined as the right derivative everywhere).
-/
noncomputable def eulerDeriv {ğ•œ : Type*} {E : Type*} [Field ğ•œ] [PartialOrder ğ•œ] [FloorSemiring ğ•œ]
    [AddCommGroup E] [Module ğ•œ E]
  (v : ğ•œ â†’ E â†’ E) (h : ğ•œ) (t0 : ğ•œ) (y0 : E) (t : ğ•œ) : E :=
  let n := Nat.floor ((t - t0) / h)
  v (t0 + n * h) (eulerPoint v h t0 y0 n)

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]
  (v : â„ â†’ E â†’ E) {h : â„} {t0 : â„} {y0 : E}

/-
The Euler path coincides with the Euler points at the grid points.
-/
theorem eulerPath_grid_point (h_pos : 0 < h) (t0 : â„) (y0 : E) (n : â„•) :
    eulerPath v h t0 y0 (t0 + n * h) = eulerPoint v h t0 y0 n := by
  simp [eulerPath, h_pos.ne']

/-
On the interval [t_n, t_{n+1}), the Euler path is given by the affine function starting at y_n
with slope v(t_n, y_n).
-/
theorem eulerPath_eq_on_Ico (h_pos : 0 < h) {n : â„•} {t : â„}
    (ht : t âˆˆ Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
    eulerPath v h t0 y0 t = eulerPoint v h t0 y0 n + (t - (t0 + n * h)) â€¢ v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
  simp [eulerPath, floor_eq_of_mem_Ico h_pos ht]

/-
On the interval [t_n, t_{n+1}), the Euler derivative is constant and equal to v(t_n, y_n).
-/
theorem eulerDeriv_eq_on_Ico (h_pos : 0 < h) {n : â„•} {t : â„}
    (ht : t âˆˆ Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
    eulerDeriv v h t0 y0 t = v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
  simp [eulerDeriv, floor_eq_of_mem_Ico h_pos ht]

/-
The Euler path is continuous on [t0, âˆ).
-/
theorem eulerPath_continuous (h_pos : 0 < h) : ContinuousOn (eulerPath v h t0 y0) (Set.Ici t0) := by
  apply continuousOn_Ici_of_Icc_grid h_pos; intro n
  apply (show ContinuousOn (fun t => eulerPoint v h t0 y0 n +
    (t - (t0 + n * h)) â€¢ v (t0 + n * h) (eulerPoint v h t0 y0 n)) _ by fun_prop).congr
  intro t ht; rcases eq_or_lt_of_le ht.2 with rfl | h_lt
  Â· norm_cast; rw [eulerPath_grid_point v h_pos t0 y0 (n + 1)]; simp [eulerStep, eulerPoint]; module
  Â· simp [eulerPath, floor_eq_of_mem_Ico h_pos âŸ¨ht.1, h_ltâŸ©]

/-
The Euler path has the expected right derivative everywhere.
-/
theorem eulerPath_hasDerivWithinAt (h_pos : 0 < h) {t : â„} (ht : t0 â‰¤ t) :
    HasDerivWithinAt (eulerPath v h t0 y0) (eulerDeriv v h t0 y0 t) (Set.Ici t) t := by
  set n := âŒŠ(t - t0) / hâŒ‹â‚Š; set tn := t0 + n * h; set yn := eulerPoint v h t0 y0 n; set c := v tn yn
  obtain âŸ¨h1, h2âŸ© := mem_Ico_floor h_pos ht; simp only [eulerDeriv]
  exact hasDerivWithinAt_Ioi_iff_Ici.mp (((hasDerivAt_id t |>.sub_const tn |>.smul_const c
    |>.const_add yn).hasDerivWithinAt.congr_of_eventuallyEq (by
      filter_upwards [Ioo_mem_nhdsGT h2] with x hx
      exact eulerPath_eq_on_Ico v h_pos âŸ¨h1.trans hx.1.le, hx.2âŸ©)
    (by simp [eulerPath, n, tn, yn, c])).congr_deriv (one_smul _ _))

variable {v} {K L : NNReal} {M : â„}
  (hv : âˆ€ t, LipschitzWith K (v t)) (hv_t : âˆ€ y, LipschitzWith L (fun t => v t y))
  (v_bound : âˆ€ t y, â€–v t yâ€– â‰¤ M)
include hv hv_t v_bound

/-
Global bound on the difference between the Euler derivative and the vector field.
-/
theorem euler_derivative_global_bound (h_pos : 0 < h) {t : â„} (ht : t0 â‰¤ t) :
    dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t)) â‰¤ h * (L + K * M) := by
  obtain âŸ¨ht1, ht2âŸ© := mem_Ico_floor h_pos ht; set n := âŒŠ(t - t0) / hâŒ‹â‚Š
  have h1 : dist (v (t0 + n * h) (eulerPoint v h t0 y0 n)) (v t (eulerPoint v h t0 y0 n)) â‰¤ L * (t - (t0 + n * h)) :=
    le_trans ((hv_t _).dist_le_mul _ _) (by rw [dist_eq_norm, Real.norm_of_nonpos (by grind)]; grind)
  have h2 : dist (eulerPoint v h t0 y0 n) (eulerPath v h t0 y0 t) â‰¤ h * M := by
    rw [eulerPath_eq_on_Ico v h_pos âŸ¨ht1, ht2âŸ©, dist_eq_norm]
    simp +decide [norm_smul, abs_of_nonneg (sub_nonneg.2 ht1)]
    refine mul_le_mul ?_ (v_bound _ _) ?_ ?_ <;> grind
  calc dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t))
      = dist (v (t0 + n * h) (eulerPoint v h t0 y0 n)) (v t (eulerPath v h t0 y0 t)) := by
        rw [eulerDeriv_eq_on_Ico v h_pos âŸ¨ht1, ht2âŸ©]
    _ â‰¤ L * (t - (t0 + n * h)) + K * (h * M) :=
        (dist_triangle _ _ _).trans (add_le_add h1 (((hv t).dist_le_mul _ _).trans (by gcongr)))
    _ â‰¤ h * (L + K * M) := by
        nlinarith [NNReal.coe_nonneg K, NNReal.coe_nonneg L, norm_nonneg (v t0 y0), v_bound t0 y0]

/-
Error bound for the Euler method using Gronwall's inequality.
-/
theorem euler_error_bound (h_pos : 0 < h) {T : â„}
    {sol : â„ â†’ E} (sol_cont : ContinuousOn sol (Set.Icc t0 T))
    (sol_deriv : âˆ€ t âˆˆ Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
    (sol_init : sol t0 = y0) :
    âˆ€ t âˆˆ Set.Icc t0 T, dist (eulerPath v h t0 y0 t) (sol t) â‰¤ gronwallBound 0 K (h * (L + K * M)) (t - t0) := by
  intro t ht
  have := dist_le_of_approx_trajectories_ODE (Î´ := 0) (Îµg := 0)
    (f' := fun t => eulerDeriv v h t0 y0 t) (g' := fun t => v t (sol t)) hv
    ((eulerPath_continuous v h_pos).mono Set.Icc_subset_Ici_self)
    (fun t ht => eulerPath_hasDerivWithinAt v h_pos ht.1)
    (fun t ht => euler_derivative_global_bound hv hv_t v_bound h_pos ht.1)
    sol_cont sol_deriv (fun _ _ => (dist_self _).le)
    (by simp [eulerPath, eulerPoint, sol_init]) t ht
  grind

/-
Convergence of the Euler method to the true solution as the time step goes to zero.
-/
theorem euler_convergence {T : â„}
    {sol : â„ â†’ E} (sol_cont : ContinuousOn sol (Set.Icc t0 T))
    (sol_deriv : âˆ€ t âˆˆ Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
    (sol_init : sol t0 = y0) :
    âˆ€ t âˆˆ Set.Icc t0 T, Filter.Tendsto (fun Î´ => eulerPath v Î´ t0 y0 t) (nhdsWithin 0 (Set.Ioi 0)) (nhds (sol t)) :=
  fun t ht => tendsto_iff_dist_tendsto_zero.mpr (squeeze_zero_norm'
    (by simpa using Filter.eventually_of_mem self_mem_nhdsWithin fun x (hx : (0 : â„) < x) =>
      euler_error_bound hv hv_t v_bound hx sol_cont sol_deriv sol_init t ht)
    (tendsto_nhdsWithin_of_tendsto_nhds <|
      Continuous.tendsto' ((gronwallBound_continuous_Îµ 0 K (t - t0)).comp
        (continuous_id.mul continuous_const)) 0 0 (by grind [gronwallBound_Îµ0_Î´0])))
