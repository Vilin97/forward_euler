/-
We implement the explicit Euler method for ODEs and prove its convergence.

Definitions:
- `eulerStep`: A single step of the Euler method.
- `eulerPoint`: The sequence of points generated by the Euler method.
- `eulerPath`: The piecewise linear interpolation of the Euler points.
- `eulerDeriv`: The right derivative of the Euler path.

Theorems:
- `euler_derivative_global_bound`: Global bound on the difference between the Euler derivative and the vector field.
- `euler_error_bound`: Error bound for the Euler method using Gronwall's inequality.
- `euler_convergence`: The Euler method converges to the true solution as the step size goes to zero.
-/

import Mathlib.Analysis.ODE.Gronwall

set_option linter.mathlibStandardSet false

/-! ## Grid helpers -/

private theorem floor_eq_of_mem_Ico {h : ‚Ñù} (h_pos : 0 < h) {a : ‚Ñù} {n : ‚Ñï} {t : ‚Ñù}
    (ht : t ‚àà Set.Ico (a + n * h) (a + (n + 1) * h)) :
    ‚åä(t - a) / h‚åã‚Çä = n :=
  by refine Nat.floor_eq_on_Ico n _ ‚ü®?_, ?_‚ü© <;>
     (first | rw [le_div_iff‚ÇÄ h_pos] | rw [div_lt_iff‚ÇÄ h_pos]) <;> grind

private theorem mem_Ico_floor {h : ‚Ñù} (h_pos : 0 < h) {a t : ‚Ñù} (ht : a ‚â§ t) :
    t ‚àà Set.Ico (a + ‚åä(t - a) / h‚åã‚Çä * h) (a + (‚Üë‚åä(t - a) / h‚åã‚Çä + 1) * h) :=
  by constructor <;> nlinarith [Nat.floor_le (div_nonneg (sub_nonneg.mpr ht) h_pos.le),
      Nat.lt_floor_add_one ((t - a) / h), mul_div_cancel‚ÇÄ (t - a) h_pos.ne']

/-- The regular grid of closed intervals `[a + n*h, a + (n+1)*h]` is locally finite. -/
theorem locallyFinite_Icc_grid {h : ‚Ñù} (h_pos : 0 < h) (a : ‚Ñù) :
    LocallyFinite fun n : ‚Ñï => Set.Icc (a + n * h) (a + (‚Üën + 1) * h) := by
  intro x; refine ‚ü®Set.Ioo (x - h) (x + h), Ioo_mem_nhds (by linarith) (by linarith),
    (Set.finite_Icc (‚åä(x - h - a) / h‚åã‚Çä) (‚åà(x + h - a) / h‚åâ‚Çä)).subset ?_‚ü©
  rintro n ‚ü®z, ‚ü®hz1, hz2‚ü©, hz3, hz4‚ü©
  refine ‚ü®Nat.lt_add_one_iff.mp ((Nat.floor_lt' (by linarith)).mpr ?_),
         Nat.cast_le.mp ((?_ : (n : ‚Ñù) ‚â§ _).trans (Nat.le_ceil _))‚ü© <;>
  (first | rw [div_lt_iff‚ÇÄ h_pos] | rw [le_div_iff‚ÇÄ h_pos]) <;> grind

/-- A function continuous on each cell `[a + n*h, a + (n+1)*h]` is continuous on `[a, ‚àû)`. -/
theorem continuousOn_Ici_of_Icc_grid {E : Type*} [TopologicalSpace E] {f : ‚Ñù ‚Üí E}
    {h : ‚Ñù} (h_pos : 0 < h) {a : ‚Ñù}
    (hf : ‚àÄ n : ‚Ñï, ContinuousOn f (Set.Icc (a + n * h) (a + (n + 1) * h))) :
    ContinuousOn f (Set.Ici a) :=
  ((locallyFinite_Icc_grid h_pos a).continuousOn_iUnion (fun _ => isClosed_Icc) (hf ¬∑)).mono
    fun t (ht : a ‚â§ t) => Set.mem_iUnion.mpr ‚ü®_, Set.Ico_subset_Icc_self (mem_Ico_floor h_pos ht)‚ü©

/-! ## Piecewise linear interpolation -/

/-- The piecewise linear interpolation of a sequence `y` with slopes `c` on a regular grid
with step size `h` starting at `a`. On `[a + n*h, a + (n+1)*h)`, the value is
`y n + (t - (a + n*h)) ‚Ä¢ c n`. -/
noncomputable def piecewiseLinear {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    (y : ‚Ñï ‚Üí E) (c : ‚Ñï ‚Üí E) (h : ‚Ñù) (a : ‚Ñù) (t : ‚Ñù) : E :=
  let n := ‚åä(t - a) / h‚åã‚Çä
  y n + (t - (a + n * h)) ‚Ä¢ c n

/-- The piecewise constant function taking value `c n` on `[a + n*h, a + (n+1)*h)`. -/
noncomputable def piecewiseConst {E : Type*} (c : ‚Ñï ‚Üí E) (h : ‚Ñù) (a : ‚Ñù) (t : ‚Ñù) : E :=
  c ‚åä(t - a) / h‚åã‚Çä

theorem piecewiseConst_eq_on_Ico {E : Type*} {c : ‚Ñï ‚Üí E} {h : ‚Ñù} {a : ‚Ñù}
    (h_pos : 0 < h) {n : ‚Ñï} {t : ‚Ñù}
    (ht : t ‚àà Set.Ico (a + n * h) (a + (n + 1) * h)) :
    piecewiseConst c h a t = c n := by
  simp [piecewiseConst, floor_eq_of_mem_Ico h_pos ht]

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  {y : ‚Ñï ‚Üí E} {c : ‚Ñï ‚Üí E} {h : ‚Ñù} {a : ‚Ñù}

theorem piecewiseLinear_grid_point (h_pos : 0 < h) (a : ‚Ñù) (n : ‚Ñï) :
    piecewiseLinear y c h a (a + n * h) = y n := by
  simp [piecewiseLinear, h_pos.ne']

theorem piecewiseLinear_eq_on_Ico (h_pos : 0 < h) {n : ‚Ñï} {t : ‚Ñù}
    (ht : t ‚àà Set.Ico (a + n * h) (a + (n + 1) * h)) :
    piecewiseLinear y c h a t = y n + (t - (a + n * h)) ‚Ä¢ c n := by
  simp [piecewiseLinear, floor_eq_of_mem_Ico h_pos ht]

/-- A piecewise linear function with matching grid values is continuous on `[a, ‚àû)`. -/
theorem piecewiseLinear_continuous (h_pos : 0 < h)
    (h_step : ‚àÄ n, y (n + 1) = y n + h ‚Ä¢ c n) :
    ContinuousOn (piecewiseLinear y c h a) (Set.Ici a) := by
  apply continuousOn_Ici_of_Icc_grid h_pos; intro n
  apply (show ContinuousOn (fun t => y n + (t - (a + n * h)) ‚Ä¢ c n) _ by fun_prop).congr
  intro t ht; rcases eq_or_lt_of_le ht.2 with rfl | h_lt
  ¬∑ norm_cast; rw [piecewiseLinear_grid_point h_pos a (n + 1), h_step]; module
  ¬∑ exact piecewiseLinear_eq_on_Ico h_pos ‚ü®ht.1, h_lt‚ü©

/-- The right derivative of a piecewise linear function is the piecewise constant slope. -/
theorem piecewiseLinear_hasDerivWithinAt (h_pos : 0 < h) {t : ‚Ñù} (ht : a ‚â§ t) :
    HasDerivWithinAt (piecewiseLinear y c h a) (piecewiseConst c h a t) (Set.Ici t) t := by
  set n := ‚åä(t - a) / h‚åã‚Çä; set tn := a + n * h
  obtain ‚ü®h1, h2‚ü© := mem_Ico_floor h_pos ht; simp only [piecewiseConst]
  exact hasDerivWithinAt_Ioi_iff_Ici.mp (((hasDerivAt_id t |>.sub_const tn |>.smul_const (c n)
    |>.const_add (y n)).hasDerivWithinAt.congr_of_eventuallyEq (by
      filter_upwards [Ioo_mem_nhdsGT h2] with x hx
      exact piecewiseLinear_eq_on_Ico h_pos ‚ü®h1.trans hx.1.le, hx.2‚ü©)
    (by simp [piecewiseLinear, n, tn])).congr_deriv (one_smul _ _))

/-! ## Euler method -/

def eulerStep {ùïú : Type*} {E : Type*} [Ring ùïú] [AddCommGroup E] [Module ùïú E]
    (v : ùïú ‚Üí E ‚Üí E) (h : ùïú) (t : ùïú) (y : E) : E :=
  y + h ‚Ä¢ v t y

def eulerPoint {ùïú : Type*} {E : Type*} [Ring ùïú] [AddCommGroup E] [Module ùïú E]
    (v : ùïú ‚Üí E ‚Üí E) (h : ùïú) (t0 : ùïú) (y0 : E) : ‚Ñï ‚Üí E
| 0 => y0
| n + 1 => eulerStep v h (t0 + n * h) (eulerPoint v h t0 y0 n)

/-- The slope of the Euler method on the n-th cell. -/
noncomputable def eulerSlope (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (t0 : ‚Ñù) (y0 : E) (n : ‚Ñï) : E :=
  v (t0 + n * h) (eulerPoint v h t0 y0 n)

/-- The piecewise linear Euler path. -/
noncomputable def eulerPath (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (t0 : ‚Ñù) (y0 : E) : ‚Ñù ‚Üí E :=
  piecewiseLinear (eulerPoint v h t0 y0) (eulerSlope v h t0 y0) h t0

/-- The right derivative of the Euler path. -/
noncomputable def eulerDeriv (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (t0 : ‚Ñù) (y0 : E) : ‚Ñù ‚Üí E :=
  piecewiseConst (eulerSlope v h t0 y0) h t0

variable {v : ‚Ñù ‚Üí E ‚Üí E} {K L : NNReal} {M : ‚Ñù}
  (hv : ‚àÄ t, LipschitzWith K (v t)) (hv_t : ‚àÄ y, LipschitzWith L (fun t => v t y))
  (v_bound : ‚àÄ t y, ‚Äñv t y‚Äñ ‚â§ M)
include hv hv_t v_bound

/-
Global bound on the difference between the Euler derivative and the vector field.
-/
theorem euler_derivative_global_bound (h_pos : 0 < h) {t : ‚Ñù} (ht : t0 ‚â§ t) :
    dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t)) ‚â§ h * (L + K * M) := by
  obtain ‚ü®ht1, ht2‚ü© := mem_Ico_floor h_pos ht; set n := ‚åä(t - t0) / h‚åã‚Çä
  have h1 : dist (v (t0 + n * h) (eulerPoint v h t0 y0 n)) (v t (eulerPoint v h t0 y0 n)) ‚â§ L * (t - (t0 + n * h)) :=
    le_trans ((hv_t _).dist_le_mul _ _) (by rw [dist_eq_norm, Real.norm_of_nonpos (by grind)]; grind)
  have h2 : dist (eulerPoint v h t0 y0 n) (eulerPath v h t0 y0 t) ‚â§ h * M := by
    rw [show eulerPath v h t0 y0 t = _ from piecewiseLinear_eq_on_Ico h_pos ‚ü®ht1, ht2‚ü©, dist_eq_norm]
    simp +decide [norm_smul, abs_of_nonneg (sub_nonneg.2 ht1), eulerSlope]
    refine mul_le_mul ?_ (v_bound _ _) ?_ ?_ <;> grind
  calc dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t))
      = dist (v (t0 + n * h) (eulerPoint v h t0 y0 n)) (v t (eulerPath v h t0 y0 t)) := by
        simp only [eulerDeriv, piecewiseConst_eq_on_Ico h_pos ‚ü®ht1, ht2‚ü©, eulerSlope]
    _ ‚â§ L * (t - (t0 + n * h)) + K * (h * M) :=
        (dist_triangle _ _ _).trans (add_le_add h1 (((hv t).dist_le_mul _ _).trans (by gcongr)))
    _ ‚â§ h * (L + K * M) := by
        nlinarith [NNReal.coe_nonneg K, NNReal.coe_nonneg L, norm_nonneg (v t0 y0), v_bound t0 y0]

/-
Error bound for the Euler method using Gronwall's inequality.
-/
theorem euler_error_bound (h_pos : 0 < h) {T : ‚Ñù}
    {sol : ‚Ñù ‚Üí E} (sol_cont : ContinuousOn sol (Set.Icc t0 T))
    (sol_deriv : ‚àÄ t ‚àà Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
    (sol_init : sol t0 = y0) :
    ‚àÄ t ‚àà Set.Icc t0 T, dist (eulerPath v h t0 y0 t) (sol t) ‚â§ gronwallBound 0 K (h * (L + K * M)) (t - t0) := by
  intro t ht
  have := dist_le_of_approx_trajectories_ODE (Œ¥ := 0) (Œµg := 0)
    (f' := eulerDeriv v h t0 y0) (g' := fun t => v t (sol t)) hv
    ((piecewiseLinear_continuous h_pos (fun n => by simp [eulerPoint, eulerStep, eulerSlope])).mono Set.Icc_subset_Ici_self)
    (fun t ht => piecewiseLinear_hasDerivWithinAt h_pos ht.1)
    (fun t ht => euler_derivative_global_bound hv hv_t v_bound h_pos ht.1)
    sol_cont sol_deriv (fun _ _ => (dist_self _).le)
    (by simp [piecewiseLinear, eulerPoint, sol_init]) t ht
  simp only [add_zero] at this; exact this

/-
Convergence of the Euler method to the true solution as the time step goes to zero.
-/
theorem euler_convergence {T : ‚Ñù}
    {sol : ‚Ñù ‚Üí E} (sol_cont : ContinuousOn sol (Set.Icc t0 T))
    (sol_deriv : ‚àÄ t ‚àà Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
    (sol_init : sol t0 = y0) :
    ‚àÄ t ‚àà Set.Icc t0 T, Filter.Tendsto (fun Œ¥ => eulerPath v Œ¥ t0 y0 t) (nhdsWithin 0 (Set.Ioi 0)) (nhds (sol t)) :=
  fun t ht => tendsto_iff_dist_tendsto_zero.mpr (squeeze_zero_norm'
    (by simpa using Filter.eventually_of_mem self_mem_nhdsWithin fun x (hx : (0 : ‚Ñù) < x) =>
      euler_error_bound hv hv_t v_bound hx sol_cont sol_deriv sol_init t ht)
    (tendsto_nhdsWithin_of_tendsto_nhds <|
      Continuous.tendsto' ((gronwallBound_continuous_Œµ 0 K (t - t0)).comp
        (continuous_id.mul continuous_const)) 0 0 (by grind [gronwallBound_Œµ0_Œ¥0])))
