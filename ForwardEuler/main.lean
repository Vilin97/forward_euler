/-
We implement the explicit Euler method for ODEs and prove its convergence.

Definitions:
- `eulerStep`: A single step of the Euler method.
- `eulerPoint`: The sequence of points generated by the Euler method.
- `eulerPath`: The piecewise linear interpolation of the Euler points.
- `eulerDeriv`: The right derivative of the Euler path.

Theorems:
- `eulerPath_grid_point`: The Euler path coincides with the Euler points at grid points.
- `eulerPath_continuous`: The Euler path is continuous.
- `eulerPath_hasDerivWithinAt`: The Euler path has the expected right derivative.
- `eulerPath_eq_on_Ico`: Explicit formula for the Euler path on intervals.
- `eulerDeriv_eq_on_Ico`: Explicit formula for the Euler derivative on intervals.
- `euler_dist_point_path`: Bound on the distance between the Euler point and the path.
- `euler_derivative_bound`: Local bound on the difference between the Euler derivative and the vector field.
- `euler_derivative_global_bound`: Global bound on the difference between the Euler derivative and the vector field.
- `euler_error_bound`: Error bound for the Euler method using Gronwall's inequality.
- `euler_convergence`: The Euler method converges to the true solution as the step size goes to zero.
-/

import Mathlib.Analysis.ODE.Gronwall

set_option linter.mathlibStandardSet false

/--
The Euler step for an ODE y' = v(t, y) with step size h is y_{n+1} = y_n + h * v(t_n, y_n).
-/
def eulerStep {ùïú : Type*} {E : Type*} [Ring ùïú] [AddCommGroup E] [Module ùïú E] (v : ùïú ‚Üí E ‚Üí E) (h : ùïú) (t : ùïú) (y : E) : E :=
  y + h ‚Ä¢ v t y

/--
The n-th point in the Euler method approximation with step size h.
-/
def eulerPoint {ùïú : Type*} {E : Type*} [Ring ùïú] [AddCommGroup E] [Module ùïú E] (v : ùïú ‚Üí E ‚Üí E) (h : ùïú) (t0 : ùïú) (y0 : E) : ‚Ñï ‚Üí E
| 0 => y0
| n + 1 => eulerStep v h (t0 + n * h) (eulerPoint v h t0 y0 n)

/--
The piecewise linear path interpolating the Euler method points.
-/
noncomputable def eulerPath {ùïú : Type*} {E : Type*} [Field ùïú] [PartialOrder ùïú] [FloorSemiring ùïú]
    [AddCommGroup E] [Module ùïú E]
  (v : ùïú ‚Üí E ‚Üí E) (h : ùïú) (t0 : ùïú) (y0 : E) (t : ùïú) : E :=
  let n := Nat.floor ((t - t0) / h)
  let tn := t0 + n * h
  let yn := eulerPoint v h t0 y0 n
  yn + (t - tn) ‚Ä¢ v tn yn

/-
The Euler path coincides with the Euler points at the grid points.
-/
theorem eulerPath_grid_point {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (n : ‚Ñï) :
  eulerPath v h t0 y0 (t0 + n * h) = eulerPoint v h t0 y0 n := by
    unfold eulerPath; norm_num [add_sub_cancel_left, h_pos.ne']

private theorem floor_eq_of_mem_Ico (h_pos : 0 < h) (t0 : ‚Ñù) (n : ‚Ñï) (t : ‚Ñù)
  (ht : t ‚àà Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  ‚åä(t - t0) / h‚åã‚Çä = n :=
  Nat.floor_eq_on_Ico n _ ‚ü®by rw [le_div_iff‚ÇÄ h_pos]; linarith [ht.1],
    by rw [div_lt_iff‚ÇÄ h_pos]; linarith [ht.2]‚ü©

private theorem mem_Ico_floor (h_pos : 0 < h) (t0 : ‚Ñù) (t : ‚Ñù) (ht : t0 ‚â§ t) :
  t ‚àà Set.Ico (t0 + ‚åä(t - t0) / h‚åã‚Çä * h) (t0 + (‚Üë‚åä(t - t0) / h‚åã‚Çä + 1) * h) :=
  ‚ü®by nlinarith [Nat.floor_le (div_nonneg (sub_nonneg.mpr ht) h_pos.le),
      mul_div_cancel‚ÇÄ (t - t0) h_pos.ne'],
   by nlinarith [Nat.lt_floor_add_one ((t - t0) / h),
      mul_div_cancel‚ÇÄ (t - t0) h_pos.ne']‚ü©

/--
The derivative of the Euler path (defined as the right derivative everywhere).
-/
noncomputable def eulerDeriv {ùïú : Type*} {E : Type*} [Field ùïú] [PartialOrder ùïú] [FloorSemiring ùïú]
    [AddCommGroup E] [Module ùïú E]
  (v : ùïú ‚Üí E ‚Üí E) (h : ùïú) (t0 : ùïú) (y0 : E) (t : ùïú) : E :=
  let n := Nat.floor ((t - t0) / h)
  let tn := t0 + n * h
  let yn := eulerPoint v h t0 y0 n
  v tn yn

/-
On the interval [t_n, t_{n+1}), the Euler path is given by the affine function starting at y_n with slope v(t_n, y_n).
-/
theorem eulerPath_eq_on_Ico {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (n : ‚Ñï)
  (t : ‚Ñù) (ht : t ‚àà Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  eulerPath v h t0 y0 t = eulerPoint v h t0 y0 n + (t - (t0 + n * h)) ‚Ä¢ v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
    simp [eulerPath, floor_eq_of_mem_Ico h_pos t0 n t ht]

/-
On the interval [t_n, t_{n+1}), the Euler derivative is constant and equal to v(t_n, y_n).
-/
theorem eulerDeriv_eq_on_Ico {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (n : ‚Ñï)
  (t : ‚Ñù) (ht : t ‚àà Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  eulerDeriv v h t0 y0 t = v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
    unfold eulerDeriv; simp [floor_eq_of_mem_Ico h_pos t0 n t ht]

/-
The Euler path is continuous on each grid interval [t‚ÇÄ + n*h, t‚ÇÄ + (n+1)*h].
-/
private theorem eulerPath_continuousOn_Icc {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (n : ‚Ñï) :
  ContinuousOn (eulerPath v h t0 y0) (Set.Icc (t0 + n * h) (t0 + (n + 1) * h)) := by
    set f := fun t => eulerPoint v h t0 y0 n + (t - (t0 + n * h)) ‚Ä¢ v (t0 + n * h) (eulerPoint v h t0 y0 n)
    suffices h_eq : Set.EqOn (eulerPath v h t0 y0) f (Set.Icc (t0 + n * h) (t0 + (n + 1) * h)) from
      (by fun_prop : ContinuousOn f _).congr h_eq
    intro t ht
    rcases eq_or_lt_of_le ht.2 with rfl | h_lt
    ¬∑ show _ = f _; simp only [f]
      rw [show (‚Üën + 1 : ‚Ñù) = ‚Üë(n + 1) from by push_cast; ring, eulerPath_grid_point v h h_pos t0 y0 (n + 1)]
      simp [eulerStep, eulerPoint]; module
    ¬∑ simp only [f, eulerPath, floor_eq_of_mem_Ico h_pos t0 n t ‚ü®ht.1, h_lt‚ü©]

/-
The Euler path is continuous on [t0, ‚àû).
-/
theorem eulerPath_continuous {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) :
  ContinuousOn (eulerPath v h t0 y0) (Set.Ici t0) := by
    set S := fun n : ‚Ñï => Set.Icc (t0 + n * h) (t0 + (‚Üën + 1) * h)
    suffices h_lf : LocallyFinite S from
      (h_lf.continuousOn_iUnion (fun n => isClosed_Icc) (fun n => eulerPath_continuousOn_Icc v h h_pos t0 y0 n)).mono
        (fun t (ht : t0 ‚â§ t) => Set.mem_iUnion.mpr ‚ü®_, Set.Ico_subset_Icc_self (mem_Ico_floor h_pos t0 t ht)‚ü©)
    intro x; refine ‚ü®Set.Ioo (x - h) (x + h), Ioo_mem_nhds (by linarith) (by linarith), ?_‚ü©
    apply Set.Finite.subset (Set.finite_Icc (‚åä(x - h - t0) / h‚åã‚Çä) (‚åà(x + h - t0) / h‚åâ‚Çä))
    rintro n ‚ü®z, ‚ü®hz1a, hz1b‚ü©, hz2a, hz2b‚ü©
    refine ‚ü®Nat.lt_add_one_iff.mp ((Nat.floor_lt' (by omega)).mpr ?_),
           Nat.cast_le.mp ((?_ : (n : ‚Ñù) ‚â§ _).trans (Nat.le_ceil _))‚ü©
    ¬∑ rw [div_lt_iff‚ÇÄ h_pos]; push_cast; nlinarith
    ¬∑ rw [le_div_iff‚ÇÄ h_pos]; nlinarith

/-
The Euler path has the expected right derivative everywhere.
-/
theorem eulerPath_hasDerivWithinAt {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (t : ‚Ñù) (ht : t0 ‚â§ t) :
  HasDerivWithinAt (eulerPath v h t0 y0) (eulerDeriv v h t0 y0 t) (Set.Ici t) t := by
    set n := ‚åä(t - t0) / h‚åã‚Çä
    set tn := t0 + n * h
    set yn := eulerPoint v h t0 y0 n
    set c := v tn yn
    -- The affine map has the right derivative
    have h_affine : HasDerivAt (fun t' => yn + (t' - tn) ‚Ä¢ c) ((1 : ‚Ñù) ‚Ä¢ c) t :=
      (hasDerivAt_id t |>.sub_const tn |>.smul_const c |>.const_add yn)
    -- eulerPath agrees with the affine map on Ioi t (within the same grid cell)
    have h_eq : ‚àÄ·∂† t' in nhdsWithin t (Set.Ioi t), eulerPath v h t0 y0 t' = yn + (t' - tn) ‚Ä¢ c := by
      have h_mem := mem_Ico_floor h_pos t0 t ht
      filter_upwards [Ioo_mem_nhdsGT h_mem.2] with x hx
      exact eulerPath_eq_on_Ico v h h_pos t0 y0 n x ‚ü®le_trans h_mem.1 hx.1.le, hx.2‚ü©
    -- Transfer and simplify
    have h_val : eulerPath v h t0 y0 t = yn + (t - tn) ‚Ä¢ c := by
      simp [eulerPath, n, tn, yn, c]
    rw [show eulerDeriv v h t0 y0 t = c from by simp [eulerDeriv, n, tn, yn, c]]
    exact hasDerivWithinAt_Ioi_iff_Ici.mp
      ((h_affine.hasDerivWithinAt.congr_of_eventuallyEq h_eq h_val.symm).congr_deriv (one_smul _ _))

/-
The distance between the Euler point and the Euler path on the interval [t_n, t_{n+1}) is bounded by h * M.
-/
theorem euler_dist_point_path {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (n : ‚Ñï)
  (M : ‚Ñù) (v_bound : ‚àÄ t y, ‚Äñv t y‚Äñ ‚â§ M)
  (t : ‚Ñù) (ht : t ‚àà Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  dist (eulerPoint v h t0 y0 n) (eulerPath v h t0 y0 t) ‚â§ h * M := by
    rw [eulerPath_eq_on_Ico v h h_pos t0 y0 n t ht, dist_eq_norm]
    simp +decide [norm_smul, abs_of_nonneg (sub_nonneg.2 ht.1)]
    exact mul_le_mul (by nlinarith [ht.1, ht.2]) (v_bound _ _) (by positivity) (by positivity)

/-
Bound on the difference between the Euler derivative and the vector field at the Euler path.
-/
theorem euler_derivative_bound {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (n : ‚Ñï)
  (K L : NNReal) (M : ‚Ñù)
  (hv : ‚àÄ t, LipschitzWith K (v t))
  (hv_t : ‚àÄ y, LipschitzWith L (fun t => v t y))
  (v_bound : ‚àÄ t y, ‚Äñv t y‚Äñ ‚â§ M)
  (t : ‚Ñù) (ht : t ‚àà Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t)) ‚â§ h * (L + K * M) := by
    have h1 : dist (v (t0 + n * h) (eulerPoint v h t0 y0 n)) (v t (eulerPoint v h t0 y0 n)) ‚â§ L * (t - (t0 + n * h)) :=
      le_trans ((hv_t _).dist_le_mul _ _) (by rw [dist_eq_norm, Real.norm_of_nonpos (by linarith [ht.1])]; linarith [ht.2])
    calc dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t))
        = dist (v (t0 + n * h) (eulerPoint v h t0 y0 n)) (v t (eulerPath v h t0 y0 t)) := by
          rw [eulerDeriv_eq_on_Ico v h h_pos t0 y0 n t ht]
      _ ‚â§ L * (t - (t0 + n * h)) + K * (h * M) :=
          dist_triangle _ _ _ |>.trans (add_le_add h1 (le_trans ((hv t).dist_le_mul _ _)
            (mul_le_mul_of_nonneg_left (euler_dist_point_path v h h_pos t0 y0 n M v_bound t ht) (NNReal.coe_nonneg _))))
      _ ‚â§ h * (L + K * M) := by
          nlinarith [ht.1, ht.2, NNReal.coe_nonneg K, NNReal.coe_nonneg L, norm_nonneg (v t0 y0), v_bound t0 y0]

/-
Global bound on the difference between the Euler derivative and the vector field.
-/
theorem euler_derivative_global_bound {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E)
  (K L : NNReal) (M : ‚Ñù)
  (hv : ‚àÄ t, LipschitzWith K (v t))
  (hv_t : ‚àÄ y, LipschitzWith L (fun t => v t y))
  (v_bound : ‚àÄ t y, ‚Äñv t y‚Äñ ‚â§ M)
  (t : ‚Ñù) (ht : t0 ‚â§ t) :
  dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t)) ‚â§ h * (L + K * M) :=
    euler_derivative_bound v h h_pos t0 y0 _ K L M hv hv_t v_bound t (mem_Ico_floor h_pos t0 t ht)

/-
Error bound for the Euler method using Gronwall's inequality.
-/
theorem euler_error_bound {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (h : ‚Ñù) (h_pos : 0 < h) (t0 : ‚Ñù) (y0 : E) (T : ‚Ñù)
  (K L : NNReal) (M : ‚Ñù)
  (hv : ‚àÄ t, LipschitzWith K (v t))
  (hv_t : ‚àÄ y, LipschitzWith L (fun t => v t y))
  (v_bound : ‚àÄ t y, ‚Äñv t y‚Äñ ‚â§ M)
  (sol : ‚Ñù ‚Üí E)
  (sol_cont : ContinuousOn sol (Set.Icc t0 T))
  (sol_deriv : ‚àÄ t ‚àà Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
  (sol_init : sol t0 = y0) :
  ‚àÄ t ‚àà Set.Icc t0 T, dist (eulerPath v h t0 y0 t) (sol t) ‚â§ gronwallBound 0 K (h * (L + K * M)) (t - t0) := by
    intro t ht
    have := dist_le_of_approx_trajectories_ODE (Œ¥ := 0) (Œµg := 0)
      (f' := fun t => eulerDeriv v h t0 y0 t) (g' := fun t => v t (sol t))
      hv ((eulerPath_continuous v h h_pos t0 y0).mono Set.Icc_subset_Ici_self)
      (fun t ht => eulerPath_hasDerivWithinAt v h h_pos t0 y0 t ht.1)
      (fun t ht => euler_derivative_global_bound v h h_pos t0 y0 K L M hv hv_t v_bound t ht.1)
      sol_cont sol_deriv (fun _ _ => (dist_self _).le)
      (by simp [eulerPath, eulerPoint, sol_init])
      t ht
    rwa [add_zero] at this

/-
Convergence of the Euler method to the true solution as the time step goes to zero.
-/
theorem euler_convergence {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  (v : ‚Ñù ‚Üí E ‚Üí E) (t0 : ‚Ñù) (y0 : E) (T : ‚Ñù)
  (K L : NNReal) (M : ‚Ñù)
  (hv : ‚àÄ t, LipschitzWith K (v t))
  (hv_t : ‚àÄ y, LipschitzWith L (fun t => v t y))
  (v_bound : ‚àÄ t y, ‚Äñv t y‚Äñ ‚â§ M)
  (sol : ‚Ñù ‚Üí E)
  (sol_cont : ContinuousOn sol (Set.Icc t0 T))
  (sol_deriv : ‚àÄ t ‚àà Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
  (sol_init : sol t0 = y0) :
  ‚àÄ t ‚àà Set.Icc t0 T, Filter.Tendsto (fun h => eulerPath v h t0 y0 t) (nhdsWithin 0 (Set.Ioi 0)) (nhds (sol t)) := by
    intro t ht
    have h_gronwall_zero : Filter.Tendsto (fun h => gronwallBound 0 K (h * (‚ÜëL + ‚ÜëK * M)) (t - t0))
        (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) :=
      tendsto_nhdsWithin_of_tendsto_nhds <|
        Continuous.tendsto' ((gronwallBound_continuous_Œµ 0 K (t - t0)).comp
          (continuous_id.mul continuous_const)) 0 0 (by simp [gronwallBound_Œµ0_Œ¥0])
    have h_bound : ‚àÄ·∂† x in nhdsWithin 0 (Set.Ioi 0),
        dist (eulerPath v x t0 y0 t) (sol t) ‚â§ gronwallBound 0 K (x * (‚ÜëL + ‚ÜëK * M)) (t - t0) :=
      Filter.eventually_of_mem self_mem_nhdsWithin fun x (hx : (0 : ‚Ñù) < x) =>
        euler_error_bound v x hx t0 y0 T K L M hv hv_t v_bound sol sol_cont sol_deriv sol_init t ht
    exact tendsto_iff_dist_tendsto_zero.mpr (squeeze_zero_norm' (by simpa using h_bound)
      h_gronwall_zero)
