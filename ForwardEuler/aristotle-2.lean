/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b5ef4ea7-1c26-4100-bc4f-5c409d97b578

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved that the explicit Euler method converges to the true solution of an ODE `x' = v(t, x)` on a finite interval `[t0, T]` as the step size `h` goes to 0.
The main theorem is `euler_method_convergence`.
We assumed that the vector field `v` is Lipschitz continuous in the second argument and continuous in the first argument.
We also assumed that the state space `E` is a finite-dimensional normed vector space.
The proof proceeds by:
1. Defining the Euler approximation `euler_approx` and its derivative `euler_deriv`.
2. Extending the vector field `v` to `v_ext` which is globally Lipschitz in time (by clamping).
3. Showing that the Euler approximation for `v` and `v_ext` coincide on `[t0, T]`.
4. Bounding the "consistency error" `||y_h' - v(t, y_h)||` using the continuity of `v`.
5. Applying a Gronwall-type inequality (`dist_le_of_approx_trajectories_ODE`) to bound the global error by the consistency error.
6. Showing that the consistency error goes to 0 as `h -> 0`, implying the global error goes to 0.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check dist_le_of_approx_trajectories_ODE

/-
Definition of the Euler method points and the piecewise linear interpolation.
-/
noncomputable def euler_point {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 : ℝ) (y0 : E) (h : ℝ) (n : ℕ) : E :=
  match n with
  | 0 => y0
  | k + 1 =>
    let tk := t0 + k * h
    let yk := euler_point v t0 y0 h k
    yk + h • v tk yk

noncomputable def euler_approx {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 : ℝ) (y0 : E) (h : ℝ) (t : ℝ) : E :=
  if h ≤ 0 then y0 else
  let n := Nat.floor ((t - t0) / h)
  let tn := t0 + n * h
  let yn := euler_point v t0 y0 h n
  yn + (t - tn) • v tn yn

#check Real.toNNReal

/-
Definition of the derivative of the Euler approximation.
-/
noncomputable def euler_deriv {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 : ℝ) (y0 : E) (h : ℝ) (t : ℝ) : E :=
  if h ≤ 0 then 0 else
  let n := Nat.floor ((t - t0) / h)
  let tn := t0 + n * h
  let yn := euler_point v t0 y0 h n
  v tn yn

/-
The Euler approximation has `euler_deriv` as its right derivative.
-/
lemma euler_approx_has_deriv {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 : ℝ) (y0 : E) (h : ℝ) (t : ℝ) (hh : 0 < h) (ht : t0 ≤ t) :
  HasDerivWithinAt (euler_approx v t0 y0 h) (euler_deriv v t0 y0 h t) (Set.Ici t) t := by
    unfold euler_approx euler_deriv;
    simp +decide [ hh.not_le ];
    -- Let's simplify the expression for the derivative.
    have h_simp : ∀ᶠ t' in nhdsWithin t (Set.Ici t), Nat.floor ((t' - t0) / h) = Nat.floor ((t - t0) / h) := by
      rw [ eventually_nhdsWithin_iff ];
      rw [ Metric.eventually_nhds_iff ];
      use ( t0 + ( Nat.floor ( ( t - t0 ) / h ) + 1 ) * h - t ) / 2, by
        nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) hh.ne' ], fun y hy₁ hy₂ => Nat.floor_eq_iff ( by
        exact div_nonneg ( by linarith [ Set.mem_Ici.mp hy₂ ] ) hh.le ) |>.2 ⟨ by
        rw [ le_div_iff₀ hh ] ; nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht ) hh.le ), abs_lt.mp hy₁, hy₂.out, mul_div_cancel₀ ( t - t0 ) hh.ne' ], by
        rw [ div_lt_iff₀ hh ] ; nlinarith [ abs_lt.mp hy₁, Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) hh.ne' ] ⟩;
    rw [ hasDerivWithinAt_iff_tendsto ];
    rw [ Filter.tendsto_congr' ( by filter_upwards [ h_simp ] with x' hx'; rw [ hx' ] ) ] ; norm_num [ mul_sub, sub_smul ]

/-
The Euler approximation is continuous on `[t0, ∞)`.
-/
lemma euler_approx_continuous {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 : ℝ) (y0 : E) (h : ℝ) (hh : 0 < h) :
  ContinuousOn (euler_approx v t0 y0 h) (Set.Ici t0) := by
    refine' ContinuousOn.congr _ fun t ht => if_neg hh.not_le;
    refine' continuousOn_of_forall_continuousAt fun t ht => _;
    by_cases htn : ∃ n : ℕ, t = t0 + n * h;
    · obtain ⟨ n, rfl ⟩ := htn; simp +decide [ hh.ne', div_eq_mul_inv ] ;
      -- For $t$ slightly less than $t0 + n * h$, we have $\lfloor (t - t0) * h⁻¹ \rfloor = n - 1$.
      have h_left : Filter.Tendsto (fun t => euler_point v t0 y0 h ⌊(t - t0) * h⁻¹⌋₊ + (t - (t0 + ⌊(t - t0) * h⁻¹⌋₊ * h)) • v (t0 + ⌊(t - t0) * h⁻¹⌋₊ * h) (euler_point v t0 y0 h ⌊(t - t0) * h⁻¹⌋₊)) (nhdsWithin (t0 + n * h) (Set.Iio (t0 + n * h))) (nhds (euler_point v t0 y0 h n)) := by
        have h_left : ∀ᶠ t in nhdsWithin (t0 + n * h) (Set.Iio (t0 + n * h)), ⌊(t - t0) * h⁻¹⌋₊ = n - 1 := by
          field_simp;
          rw [ eventually_nhdsWithin_iff ];
          rw [ Metric.eventually_nhds_iff ];
          refine' ⟨ h, hh, fun y hy₁ hy₂ => _ ⟩ ; rcases n with ( _ | n ) <;> norm_num at *;
          · rw [ div_lt_iff₀ ] <;> linarith [ abs_lt.mp hy₁ ];
          · exact Nat.floor_eq_iff ( div_nonneg ( by nlinarith [ abs_lt.mp hy₁ ] ) hh.le ) |>.2 ⟨ by rw [ le_div_iff₀ hh ] ; nlinarith [ abs_lt.mp hy₁ ], by rw [ div_lt_iff₀ hh ] ; nlinarith [ abs_lt.mp hy₁ ] ⟩;
        rw [ Filter.tendsto_congr' ( by filter_upwards [ h_left ] with t ht; rw [ ht ] ) ];
        rcases n <;> simp_all +decide [ Nat.cast_succ, add_mul ];
        · exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ ( by simp +decide ) );
        · refine' tendsto_nhdsWithin_of_tendsto_nhds _;
          refine' Continuous.tendsto' _ _ _ _ <;> norm_num [ hh.ne', add_assoc ];
          · fun_prop (disch := solve_by_elim);
          · exact?;
      -- For $t$ slightly more than $t0 + n * h$, we have $\lfloor (t - t0) * h⁻¹ \rfloor = n$.
      have h_right : Filter.Tendsto (fun t => euler_point v t0 y0 h ⌊(t - t0) * h⁻¹⌋₊ + (t - (t0 + ⌊(t - t0) * h⁻¹⌋₊ * h)) • v (t0 + ⌊(t - t0) * h⁻¹⌋₊ * h) (euler_point v t0 y0 h ⌊(t - t0) * h⁻¹⌋₊)) (nhdsWithin (t0 + n * h) (Set.Ioi (t0 + n * h))) (nhds (euler_point v t0 y0 h n)) := by
        have h_right : ∀ᶠ t in nhdsWithin (t0 + n * h) (Set.Ioi (t0 + n * h)), ⌊(t - t0) * h⁻¹⌋₊ = n := by
          rw [ eventually_nhdsWithin_iff ];
          filter_upwards [ Ioo_mem_nhds ( show t0 + n * h > t0 + n * h - h by linarith ) ( show t0 + n * h < t0 + n * h + h by linarith ) ] with x hx hx' using Nat.floor_eq_iff ( div_nonneg ( by nlinarith [ hx.1, hx.2, hx'.out ] ) hh.le ) |>.2 ⟨ by nlinarith [ hx.1, hx.2, hx'.out, mul_div_cancel₀ ( x - t0 ) hh.ne' ], by nlinarith [ hx.1, hx.2, hx'.out, mul_div_cancel₀ ( x - t0 ) hh.ne' ] ⟩;
        rw [ Filter.tendsto_congr' ( by filter_upwards [ h_right ] with t ht; rw [ ht ] ) ] ; exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ <| by simp +decide [ hh.ne' ] ) ;
      refine' continuousAt_iff_continuous_left'_right'.mpr _;
      simp_all +decide [ ContinuousWithinAt ];
      simp_all +decide [ hh.ne' ];
    · -- Since $t$ is not of the form $t0 + n * h$, we have $\lfloor (t - t0) / h \rfloor = n$ for some $n$ such that $t0 + n * h < t < t0 + (n + 1) * h$.
      obtain ⟨n, hn⟩ : ∃ n : ℕ, t0 + n * h < t ∧ t < t0 + (n + 1) * h := by
        exact ⟨ ⌊ ( t - t0 ) / h⌋₊, lt_of_le_of_ne ( by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.2 ht ) hh.le ), mul_div_cancel₀ ( t - t0 ) hh.ne' ] ) fun h => htn ⟨ _, h.symm ⟩, by nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) hh.ne' ] ⟩;
      refine' ContinuousAt.congr _ _;
      use fun t => euler_point v t0 y0 h n + ( t - ( t0 + n * h ) ) • v ( t0 + n * h ) ( euler_point v t0 y0 h n );
      · fun_prop;
      · filter_upwards [ Ioo_mem_nhds hn.1 hn.2 ] with x hx;
        norm_num [ show ⌊ ( x - t0 ) / h⌋₊ = n by exact Nat.floor_eq_iff ( div_nonneg ( sub_nonneg.2 <| by nlinarith [ hx.1 ] ) hh.le ) |>.2 ⟨ by nlinarith [ hx.1, hx.2, mul_div_cancel₀ ( x - t0 ) hh.ne' ], by nlinarith [ hx.1, hx.2, mul_div_cancel₀ ( x - t0 ) hh.ne' ] ⟩ ]

/-
The Euler approximations are uniformly bounded on `[t0, T]` for all small `h`.
-/
lemma euler_approx_bounded {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∃ M, ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T, ‖euler_approx v t0 y0 h t‖ ≤ M := by
    -- By definition of $euler_approx$, we know that its values are bounded by the values of $euler_point$.
    have h_euler_point_bound : ∃ M, ∀ h ∈ Set.Ioo 0 1, ∀ n : ℕ, ∀ t ∈ Set.Icc t0 T, t0 + n * h ≤ t → t < t0 + (n + 1) * h → ‖euler_point v t0 y0 h n‖ ≤ M := by
      -- By definition of $euler_point$, we know that its values are bounded by the values of $euler_approx$. Use this fact.
      have h_euler_point_bound : ∃ M, ∀ h ∈ Set.Ioo 0 1, ∀ n : ℕ, t0 + n * h ≤ T → ‖euler_point v t0 y0 h n‖ ≤ M := by
        have h_lip_const : ∃ L, ∀ t ∈ Set.Icc t0 T, ∀ y, ‖v t y‖ ≤ L * (1 + ‖y‖) := by
          have h_bound : ∃ L, ∀ t ∈ Set.Icc t0 T, ∀ y, ‖v t y‖ ≤ L * (1 + ‖y‖) := by
            have h_cont_bounded : ∃ M, ∀ t ∈ Set.Icc t0 T, ‖v t 0‖ ≤ M := by
              have h_cont_bounded : ContinuousOn (fun t => v t 0) (Set.Icc t0 T) := by
                exact h_cont.comp ( continuousOn_id.prodMk continuousOn_const ) fun x hx => ⟨ hx, Set.mem_univ _ ⟩;
              exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_cont_bounded
            obtain ⟨ M, hM ⟩ := h_cont_bounded;
            use M + K.toNNReal;
            intro t ht y;
            have := h_lip t ht;
            have := this.norm_sub_le y 0;
            simp +zetaDelta at *;
            nlinarith [ norm_nonneg ( v t y - v t 0 ), norm_nonneg ( v t 0 ), norm_nonneg y, hM t ht.1 ht.2, le_max_left K 0, le_max_right K 0, norm_sub_norm_le ( v t y ) ( v t 0 ) ];
          exact h_bound
        obtain ⟨ L, hL ⟩ := h_lip_const;
        -- By induction on $n$, we can show that $\|y_n\| \ tq \|y_0\| e^{L(T-t_0)} + \frac{L}{L}(e^{L(T-t_0)} - 1)$.
        have h_inductive_bound : ∀ h ∈ Set.Ioo 0 1, ∀ n : ℕ, t0 + n * h ≤ T → ‖euler_point v t0 y0 h n‖ ≤ ‖y0‖ * Real.exp (L * (T - t0)) + (Real.exp (L * (T - t0)) - 1) := by
          intro h hh n hn
          have h_inductive_step : ∀ k : ℕ, t0 + k * h ≤ T → ‖euler_point v t0 y0 h k‖ ≤ ‖y0‖ * (1 + L * h) ^ k + ( (1 + L * h) ^ k - 1 ) := by
            intro k hk
            induction' k with k ih;
            · simp +decide [ euler_point ];
            · -- Apply the induction hypothesis and the Lipschitz condition to bound the norm.
              have h_bound : ‖euler_point v t0 y0 h (k + 1)‖ ≤ ‖euler_point v t0 y0 h k‖ + h * L * (1 + ‖euler_point v t0 y0 h k‖) := by
                refine' le_trans ( norm_add_le _ _ ) _;
                simp +decide [ norm_smul, abs_of_nonneg hh.1.le ];
                simpa only [ mul_assoc ] using mul_le_mul_of_nonneg_left ( hL _ ⟨ by nlinarith [ hh.1, hh.2 ], by push_cast at *; nlinarith [ hh.1, hh.2 ] ⟩ _ ) hh.1.le;
              refine' le_trans h_bound _;
              convert add_le_add ( ih ( by push_cast at *; linarith [ hh.1, hh.2 ] ) ) ( mul_le_mul_of_nonneg_left ( add_le_add_left ( ih ( by push_cast at *; linarith [ hh.1, hh.2 ] ) ) 1 ) ( mul_nonneg hh.1.le ( show 0 ≤ L by have := hL t0 ⟨ by linarith, by linarith ⟩ 0; norm_num at this; nlinarith [ norm_nonneg ( v t0 0 ) ] ) ) ) using 1 ; ring;
          -- Since $h \in (0, 1)$, we have $(1 + L * h)^n \leq \exp(L * n * h)$.
          have h_exp_bound : (1 + L * h) ^ n ≤ Real.exp (L * n * h) := by
            rw [ ← Real.rpow_natCast, Real.rpow_def_of_pos ] <;> norm_num;
            · have h_exp_bound : Real.log (1 + L * h) ≤ L * h := by
                exact le_trans ( Real.log_le_sub_one_of_pos ( by nlinarith [ hh.1, hh.2, show 0 ≤ L by have := hL t0 ⟨ by linarith, by linarith ⟩ 0; norm_num at this; linarith [ norm_nonneg ( v t0 0 ) ] ] ) ) ( by linarith );
              nlinarith;
            · nlinarith [ hh.1, hh.2, show 0 ≤ L by have := hL t0 ⟨ by linarith, by linarith ⟩ 0; norm_num at this; linarith [ norm_nonneg ( v t0 0 ) ] ];
          refine' le_trans ( h_inductive_step n hn ) _;
          gcongr;
          · exact h_exp_bound.trans ( Real.exp_le_exp.mpr ( by nlinarith [ hh.1, hh.2, mul_le_mul_of_nonneg_left hh.1.le ( show 0 ≤ L by have := hL t0 ⟨ by linarith, by linarith ⟩ 0; norm_num at this; linarith [ norm_nonneg ( v t0 0 ) ] ) ] ) );
          · exact h_exp_bound.trans ( Real.exp_le_exp.mpr ( by nlinarith [ hh.1, hh.2, mul_le_mul_of_nonneg_left hh.1.le ( show 0 ≤ L by have := hL t0 ⟨ by linarith, by linarith ⟩ 0; norm_num at this; linarith [ norm_nonneg ( v t0 0 ) ] ) ] ) );
        exact ⟨ _, h_inductive_bound ⟩;
      exact ⟨ h_euler_point_bound.choose, fun h hh n t ht h₁ h₂ => h_euler_point_bound.choose_spec h hh n ( by linarith [ ht.2 ] ) ⟩;
    -- By definition of $euler_approx$, we know that its values are bounded by the values of $euler_point$ and the bounds on $v$.
    obtain ⟨M, hM⟩ := h_euler_point_bound
    obtain ⟨C, hC⟩ : ∃ C, ∀ t ∈ Set.Icc t0 T, ∀ y, ‖v t y‖ ≤ C + K.toNNReal * ‖y - y0‖ := by
      have h_bound_v : ∃ C, ∀ t ∈ Set.Icc t0 T, ‖v t y0‖ ≤ C := by
        have h_cont_v : ContinuousOn (fun t => v t y0) (Set.Icc t0 T) := by
          exact h_cont.comp ( continuousOn_id.prodMk continuousOn_const ) fun x hx => ⟨ hx, Set.mem_univ _ ⟩;
        exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_cont_v;
      obtain ⟨ C, hC ⟩ := h_bound_v;
      use C + K.toNNReal * ‖y0‖ + K.toNNReal * ‖y0‖;
      intro t ht y; specialize h_lip t ht; have := h_lip.norm_sub_le y y0; simp_all +decide [ add_assoc ] ;
      have := norm_add_le ( v t y - v t y0 ) ( v t y0 ) ; simp_all +decide [ add_assoc ] ;
      nlinarith [ hC t ht.1 ht.2, norm_nonneg ( y - y0 ), norm_nonneg y0, le_max_left K 0, le_max_right K 0 ];
    -- By definition of $euler_approx$, we know that its values are bounded by the values of $euler_point$ and the bounds on $v$. Use this fact.
    have h_euler_approx_bound : ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T, ‖euler_approx v t0 y0 h t‖ ≤ M + h * (C + K.toNNReal * (M + ‖y0‖)) := by
      intro h hh t ht
      obtain ⟨n, hn⟩ : ∃ n : ℕ, t0 + n * h ≤ t ∧ t < t0 + (n + 1) * h := by
        exact ⟨ ⌊ ( t - t0 ) / h⌋₊, by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.2 ht.1 ) hh.1.le ), hh.1, hh.2, mul_div_cancel₀ ( t - t0 ) hh.1.ne' ], by nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), hh.1, hh.2, mul_div_cancel₀ ( t - t0 ) hh.1.ne' ] ⟩;
      have h_euler_approx_bound : ‖euler_approx v t0 y0 h t‖ ≤ ‖euler_point v t0 y0 h n‖ + h * ‖v (t0 + n * h) (euler_point v t0 y0 h n)‖ := by
        unfold euler_approx;
        split_ifs <;> simp_all +decide [ Nat.floor_eq_iff, div_lt_iff₀, le_div_iff₀ ];
        · linarith;
        · rw [ show ⌊ ( t - t0 ) / h⌋₊ = n by exact Nat.floor_eq_iff ( div_nonneg ( by linarith ) hh.1.le ) |>.2 ⟨ by nlinarith [ mul_div_cancel₀ ( t - t0 ) hh.1.ne' ], by nlinarith [ mul_div_cancel₀ ( t - t0 ) hh.1.ne' ] ⟩ ];
          exact le_trans ( norm_add_le _ _ ) ( add_le_add_left ( by rw [ norm_smul, Real.norm_of_nonneg ( by nlinarith ) ] ; exact mul_le_mul_of_nonneg_right ( by nlinarith ) ( norm_nonneg _ ) ) _ );
      refine' le_trans h_euler_approx_bound ( add_le_add ( hM h hh n t ht hn.1 hn.2 ) ( mul_le_mul_of_nonneg_left ( le_trans ( hC _ ⟨ _, _ ⟩ _ ) _ ) hh.1.le ) );
      · nlinarith [ hh.1 ];
      · linarith [ ht.2 ];
      · exact add_le_add_left ( mul_le_mul_of_nonneg_left ( by simpa using norm_sub_le ( euler_point v t0 y0 h n ) y0 |> le_trans <| add_le_add_right ( hM h hh n t ht hn.1 hn.2 ) _ ) <| by positivity ) _;
    refine' ⟨ M + 1 * ( C + K.toNNReal * ( M + ‖y0‖ ) ), fun h hh t ht => le_trans ( h_euler_approx_bound h hh t ht ) _ ⟩;
    norm_num +zetaDelta at *;
    exact mul_le_of_le_one_left ( add_nonneg ( show 0 ≤ C by have := hC t0 le_rfl h_time y0; norm_num at this; linarith [ norm_nonneg ( v t0 y0 ) ] ) ( mul_nonneg ( by positivity ) ( add_nonneg ( show 0 ≤ M by exact le_trans ( norm_nonneg _ ) ( hM ( 1 / 2 ) ( by norm_num ) ( by norm_num ) 0 t0 le_rfl ( by linarith ) ( by linarith ) ( by linarith ) ) ) ( norm_nonneg y0 ) ) ) ) hh.2.le

/-
The vector field `v` is uniformly bounded on the set of all Euler approximations.
-/
lemma v_bounded_on_euler_set {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∃ C, ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T, ‖v t (euler_approx v t0 y0 h t)‖ ≤ C := by
    -- By `euler_approx_bounded`, there exists a constant $M$ such that $\|euler_approx v t0 y0 h t\| \leq M$ for all $h \in (0, 1)$ and $t \in [t0, T]$.
    obtain ⟨M, hM⟩ : ∃ M, ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T, ‖euler_approx v t0 y0 h t‖ ≤ M := by
      exact?;
    -- Using the Lipschitz property, we can bound the norm of $v(t, y)$ as follows:
    have h_lip_bound : ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T, ‖v t (euler_approx v t0 y0 h t)‖ ≤ ‖v t y0‖ + K.toNNReal * ‖euler_approx v t0 y0 h t - y0‖ := by
      intro h hh t ht
      have h_lip_bound : ‖v t (euler_approx v t0 y0 h t) - v t y0‖ ≤ K.toNNReal * ‖euler_approx v t0 y0 h t - y0‖ := by
        exact h_lip t ht |> fun h => h.norm_sub_le _ _ |> le_trans <| by simp +decide [ mul_comm ] ;
      simpa using norm_add_le ( v t y0 ) ( v t ( euler_approx v t0 y0 h t ) - v t y0 ) |> le_trans <| add_le_add_left h_lip_bound _;
    -- Since $v(t, y0)$ is continuous on the compact interval $[t0, T]$, it is bounded.
    obtain ⟨C0, hC0⟩ : ∃ C0, ∀ t ∈ Set.Icc t0 T, ‖v t y0‖ ≤ C0 := by
      exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( show ContinuousOn ( fun t => v t y0 ) ( Set.Icc t0 T ) from h_cont.comp ( continuousOn_id.prodMk continuousOn_const ) fun x hx => ⟨ hx, Set.mem_univ _ ⟩ );
    refine' ⟨ C0 + K.toNNReal * ( M + ‖y0‖ ), fun h hh t ht => le_trans ( h_lip_bound h hh t ht ) _ ⟩;
    exact add_le_add ( hC0 t ht ) ( mul_le_mul_of_nonneg_left ( by simpa using norm_sub_le ( euler_approx v t0 y0 h t ) y0 |> le_trans <| add_le_add ( hM h hh t ht ) le_rfl ) <| NNReal.coe_nonneg _ )

/-
The Euler approximation at `t0 + n * h` is equal to the `n`-th Euler point.
-/
lemma euler_approx_at_step {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 : ℝ) (y0 : E) (h : ℝ) (n : ℕ) (hh : 0 < h) :
  euler_approx v t0 y0 h (t0 + n * h) = euler_point v t0 y0 h n := by
    unfold euler_approx;
    simp +decide [ hh.not_le, mul_div_cancel_right₀ _ hh.ne' ]

/-
The difference between the Euler approximation and the value at the start of the step is bounded by `h * C`.
-/
lemma euler_approx_diff_le {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∃ C, ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T,
    ‖euler_approx v t0 y0 h t - euler_point v t0 y0 h (Nat.floor ((t - t0) / h))‖ ≤ h * C := by
      obtain ⟨ C, hC ⟩ := v_bounded_on_euler_set v t0 T y0 K h_time h_lip h_cont;
      refine' ⟨ C, fun h hh t ht => _ ⟩;
      rw [ show euler_approx v t0 y0 h t = euler_point v t0 y0 h ⌊ ( t - t0 ) / h⌋₊ + ( t - ( t0 + ⌊ ( t - t0 ) / h⌋₊ * h ) ) • v ( t0 + ⌊ ( t - t0 ) / h⌋₊ * h ) ( euler_point v t0 y0 h ⌊ ( t - t0 ) / h⌋₊ ) from ?_ ];
      · simp +decide [ norm_smul, mul_comm ];
        rw [ mul_comm ];
        gcongr;
        · exact le_trans ( norm_nonneg _ ) ( hC h hh t0 ⟨ by linarith, by linarith ⟩ );
        · convert hC h hh ( t0 + h * ⌊ ( t - t0 ) / h⌋₊ ) ⟨ _, _ ⟩ using 1;
          · rw [ show euler_approx v t0 y0 h ( t0 + h * ⌊ ( t - t0 ) / h⌋₊ ) = euler_point v t0 y0 h ⌊ ( t - t0 ) / h⌋₊ from ?_ ];
            convert euler_approx_at_step v t0 y0 h ⌊ ( t - t0 ) / h⌋₊ hh.1 using 1;
            rw [ mul_comm ];
          · exact le_add_of_nonneg_right ( mul_nonneg hh.1.le ( Nat.cast_nonneg _ ) );
          · nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.2 ht.1 ) hh.1.le ), hh.1, hh.2, ht.2, mul_div_cancel₀ ( t - t0 ) hh.1.ne' ];
        · exact abs_le.mpr ⟨ by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht.1 ) hh.1.le ), hh.1, hh.2, mul_div_cancel₀ ( t - t0 ) hh.1.ne' ], by nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), hh.1, hh.2, mul_div_cancel₀ ( t - t0 ) hh.1.ne' ] ⟩;
      · unfold euler_approx; aesop;

/-
The difference between the Euler approximation and the value at the start of the step is bounded by `h * C`, assuming finite dimensionality.
-/
lemma euler_approx_diff_le_of_finite_dim {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∃ C, ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T,
    ‖euler_approx v t0 y0 h t - euler_point v t0 y0 h (Nat.floor ((t - t0) / h))‖ ≤ h * C := by
      exact?

/-
The consistency error of the Euler method tends to 0 as `h -> 0` uniformly on `[t0, T]`, assuming finite dimensionality.
-/
lemma euler_consistency_error {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∀ ε > 0, ∃ δ > 0, ∀ h ∈ Set.Ioo 0 δ, ∀ t ∈ Set.Icc t0 T,
    ‖euler_deriv v t0 y0 h t - v t (euler_approx v t0 y0 h t)‖ < ε := by
      intro ε hε;
      -- By `euler_approx_bounded`, there exists `M` such that `||euler_approx ...|| <= M`.
      obtain ⟨M, hM⟩ : ∃ M, ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T, ‖euler_approx v t0 y0 h t‖ ≤ M := by
        apply_rules [ euler_approx_bounded ];
      -- Let `S = [t0, T] x B(0, M)`. `S` is compact because `E` is finite dimensional.
      set S : Set (ℝ × E) := Set.Icc t0 T ×ˢ Metric.closedBall 0 M
      have hS_compact : IsCompact S := by
        exact isCompact_Icc.prod ( ProperSpace.isCompact_closedBall _ _ );
      -- By `euler_approx_diff_le`, `||yn - y(t)|| <= h * C`.
      obtain ⟨C, hC⟩ : ∃ C, ∀ h ∈ Set.Ioo 0 1, ∀ t ∈ Set.Icc t0 T, ‖euler_approx v t0 y0 h t - euler_point v t0 y0 h (Nat.floor ((t - t0) / h))‖ ≤ h * C := by
        exact?;
      -- By `euler_approx_diff_le`, `||v(tn, yn) - v(tn, y(t))|| <= K * ||yn - y(t)|| <= K * C * h`.
      obtain ⟨δ1, hδ1⟩ : ∃ δ1 > 0, ∀ p q : ℝ × E, p ∈ S → q ∈ S → dist p q < δ1 → ‖v p.1 p.2 - v q.1 q.2‖ < ε / 2 := by
        have h_cont_on_S : ContinuousOn (fun p : ℝ × E => v p.1 p.2) S := by
          exact h_cont.mono ( Set.prod_mono ( Set.Subset.refl _ ) ( Set.subset_univ _ ) );
        have := Metric.uniformContinuousOn_iff.mp ( hS_compact.uniformContinuousOn_of_continuous h_cont_on_S ) ( ε / 2 ) ( half_pos hε );
        exact ⟨ this.choose, this.choose_spec.1, fun p q hp hq h => by simpa only [ dist_eq_norm ] using this.choose_spec.2 p hp q hq h ⟩;
      refine' ⟨ Min.min 1 ( δ1 / ( Max.max C 1 ) ), _, _ ⟩ <;> simp_all +decide [ dist_eq_norm ];
      intro h hh hh' hh'' t ht ht'
      have h_dist : ‖euler_approx v t0 y0 h t - euler_point v t0 y0 h (Nat.floor ((t - t0) / h))‖ < δ1 := by
        refine' lt_of_le_of_lt ( hC h hh hh' t ht ht' ) _;
        rw [ lt_div_iff₀ ] at hh'' <;> nlinarith [ le_max_left C 1, le_max_right C 1 ];
      have h_dist : ‖v (t0 + ⌊(t - t0) / h⌋₊ * h) (euler_point v t0 y0 h ⌊(t - t0) / h⌋₊) - v t (euler_approx v t0 y0 h t)‖ < ε / 2 := by
        apply hδ1.right;
        · refine' ⟨ ⟨ _, _ ⟩, _ ⟩;
          · exact le_add_of_nonneg_right ( mul_nonneg ( Nat.cast_nonneg _ ) hh.le );
          · nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht ) hh.le ), mul_div_cancel₀ ( t - t0 ) hh.ne' ];
          · simp +zetaDelta at *;
            convert hM h hh hh' ( t0 + ⌊ ( t - t0 ) / h⌋₊ * h ) ( by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht ) hh.le ), mul_div_cancel₀ ( t - t0 ) hh.ne' ] ) ( by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht ) hh.le ), mul_div_cancel₀ ( t - t0 ) hh.ne' ] ) using 1;
            rw [ euler_approx_at_step ];
            exact?;
        · exact ⟨ ⟨ ht, ht' ⟩, mem_closedBall_zero_iff.mpr ( hM h hh hh' t ht ht' ) ⟩;
        · rw [ lt_div_iff₀ ( by positivity ) ] at hh'';
          rw [ abs_lt ];
          constructor <;> nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht ) hh.le ), Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) hh.ne', le_max_left C 1, le_max_right C 1 ];
        · rwa [ norm_sub_rev ];
      unfold euler_deriv;
      split_ifs <;> simp_all +decide [ not_le_of_gt ];
      linarith

/-
Extension of the vector field `v` to all times by clamping the time to `[t0, T]`.
-/
def v_ext {E : Type*} (v : ℝ → E → E) (t0 T : ℝ) (t : ℝ) (y : E) : E :=
  v (max t0 (min t T)) y

/-
The extended vector field `v_ext` is Lipschitz continuous with constant `K` for all `t`.
-/
lemma v_ext_lip {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (K : NNReal)
  (h_time : t0 ≤ T)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith K (v t)) :
  ∀ t, LipschitzWith K (v_ext v t0 T t) := by
    intro t
    unfold v_ext;
    grind

/-
The extended vector field `v_ext` agrees with `v` on `[t0, T]`.
-/
lemma v_ext_eq {E : Type*} (v : ℝ → E → E) (t0 T : ℝ) (t : ℝ) (ht : t ∈ Set.Icc t0 T) (y : E) :
  v_ext v t0 T t y = v t y := by
    unfold v_ext; aesop;

/-
The Euler approximation using `v` is the same as using `v_ext` on `[t0, T]`.
-/
lemma euler_approx_eq_v_ext {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (y0 : E) (h : ℝ) (hh : 0 < h)
  (h_time : t0 ≤ T) :
  ∀ t ∈ Set.Icc t0 T, euler_approx v t0 y0 h t = euler_approx (v_ext v t0 T) t0 y0 h t := by
    -- By definition of `euler_approx`, we have:
    intros t ht
    unfold euler_approx;
    -- By definition of `euler_point`, we have:
    have h_euler_point : ∀ n : ℕ, n ≤ Nat.floor ((t - t0) / h) → euler_point v t0 y0 h n = euler_point (v_ext v t0 T) t0 y0 h n := by
      intro n hn;
      induction' n with n ih <;> simp_all +decide [ euler_point ];
      rw [ ih ( Nat.le_of_succ_le hn ), show t0 + ( n : ℝ ) * h = max t0 ( min ( t0 + ( n : ℝ ) * h ) T ) from ?_ ];
      · unfold v_ext; aesop;
      · rw [ max_eq_right ];
        · rw [ min_eq_left ];
          nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.2 ht.1 ) hh.le ), mul_div_cancel₀ ( t - t0 ) hh.ne', show ( n : ℝ ) + 1 ≤ ⌊ ( t - t0 ) / h⌋₊ by exact_mod_cast hn ];
        · exact le_min ( by nlinarith ) ( by nlinarith );
    simp_all +decide [ v_ext ];
    rw [ min_eq_left ] ; nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht.1 ) hh.le ), mul_div_cancel₀ ( t - t0 ) hh.ne' ] ;

/-
The extended vector field `v_ext` is continuous.
-/
lemma v_ext_continuous {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 T : ℝ) (h_time : t0 ≤ T)
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  Continuous (fun p : ℝ × E ↦ v_ext v t0 T p.1 p.2) := by
    convert h_cont.comp_continuous ( show Continuous fun p : ℝ × E => ( Max.max t0 ( Min.min p.1 T ), p.2 ) from ?_ ) ?_ using 1;
    · fun_prop;
    · grind

#check gronwallBound

/-
If the consistency error is bounded by `ε_consist`, then the error of the Euler method is bounded by the Gronwall bound.
-/
lemma euler_dist_le {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (x : ℝ → E) (t0 T : ℝ) (y0 : E) (K : NNReal) (ε_consist : ℝ)
  (h_time : t0 ≤ T)
  (h_init : x t0 = y0)
  (h_sol : ∀ t ∈ Set.Icc t0 T, HasDerivWithinAt x (v t (x t)) (Set.Icc t0 T) t)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith K (v t))
  (h : ℝ) (hh : 0 < h)
  (h_consist : ∀ t ∈ Set.Icc t0 T, ‖euler_deriv v t0 y0 h t - v t (euler_approx v t0 y0 h t)‖ ≤ ε_consist) :
  ∀ t ∈ Set.Icc t0 T, dist (x t) (euler_approx v t0 y0 h t) ≤ gronwallBound 0 K ε_consist (t - t0) := by
    intro t ht;
    have := @dist_le_of_approx_trajectories_ODE E;
    convert this ( fun t => v_ext_lip v t0 T K h_time h_lip t ) ( show ContinuousOn ( fun t => x t ) ( Set.Icc t0 T ) from ?_ ) ( show ∀ t ∈ Set.Ico t0 T, HasDerivWithinAt ( fun t => x t ) ( v_ext v t0 T t ( x t ) ) ( Set.Ici t ) t from ?_ ) ( show ∀ t ∈ Set.Ico t0 T, Dist.dist ( v_ext v t0 T t ( x t ) ) ( v_ext v t0 T t ( x t ) ) ≤ 0 from ?_ ) ( show ContinuousOn ( fun t => euler_approx v t0 y0 h t ) ( Set.Icc t0 T ) from ?_ ) ( show ∀ t ∈ Set.Ico t0 T, HasDerivWithinAt ( fun t => euler_approx v t0 y0 h t ) ( euler_deriv v t0 y0 h t ) ( Set.Ici t ) t from ?_ ) ( show ∀ t ∈ Set.Ico t0 T, Dist.dist ( euler_deriv v t0 y0 h t ) ( v_ext v t0 T t ( euler_approx v t0 y0 h t ) ) ≤ ε_consist from ?_ ) ( show Dist.dist ( x t0 ) ( euler_approx v t0 y0 h t0 ) ≤ 0 from ?_ ) t ht using 1;
    all_goals norm_num [ h_init, gronwallBound ];
    exact fun t ht => ( h_sol t ht |> HasDerivWithinAt.continuousWithinAt );
    · intro t ht₁ ht₂; specialize h_sol t ⟨ ht₁, ht₂.le ⟩ ; exact (by
      rw [ v_ext ];
      simpa [ ht₁, ht₂.le ] using h_sol.mono_of_mem_nhdsWithin ( Icc_mem_nhdsGT_of_mem ⟨ by linarith, by linarith ⟩ ));
    · exact ContinuousOn.mono ( euler_approx_continuous v t0 y0 h hh ) ( Set.Icc_subset_Ici_self );
    · exact fun t ht₁ ht₂ => euler_approx_has_deriv v t0 y0 h t hh ht₁;
    · intro t ht₁ ht₂;
      convert h_consist t ⟨ ht₁, ht₂.le ⟩ using 1;
      rw [ v_ext_eq ];
      · rw [ dist_eq_norm ];
      · grind;
    · unfold euler_approx; aesop;

/-
The Gronwall bound with zero initial error is bounded linearly by `ε`.
-/
lemma gronwallBound_le_eps_mul_C {K T ε : ℝ} (hK : 0 ≤ K) (hT : 0 ≤ T) (hε : 0 ≤ ε) :
  ∃ C > 0, ∀ t ∈ Set.Icc 0 T, gronwallBound 0 K ε t ≤ ε * C := by
    by_cases hK_pos : 0 < K;
    · unfold gronwallBound;
      field_simp;
      exact ⟨ ( Real.exp ( K * T ) - 1 ) / K + 1, by exact add_pos_of_nonneg_of_pos ( div_nonneg ( sub_nonneg.mpr <| Real.one_le_exp <| by positivity ) hK ) zero_lt_one, fun t ht => by rw [ if_neg hK_pos.ne' ] ; rw [ div_le_iff₀ <| by positivity ] ; nlinarith [ Real.exp_le_exp.mpr <| show K * t ≤ K * T by nlinarith [ ht.1, ht.2 ], Real.exp_pos ( K * t ), Real.exp_pos ( K * T ), mul_div_cancel₀ ( Real.exp ( K * T ) - 1 ) hK_pos.ne' ] ⟩;
    · exact ⟨ Max.max T 1 + 1, by positivity, fun t ht => by rw [ show K = 0 by linarith ] ; rw [ gronwallBound ] ; norm_num ; nlinarith [ ht.1, ht.2, le_max_left T 1, le_max_right T 1 ] ⟩

/-
The explicit Euler method converges to the true solution of an ODE `x' = v(t, x)` on a finite interval `[t0, T]` as the step size `h` goes to 0, assuming `v` is Lipschitz and continuous, and the space is finite dimensional.
-/
theorem euler_method_convergence {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E]
  (v : ℝ → E → E) (x : ℝ → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_init : x t0 = y0)
  (h_sol : ∀ t ∈ Set.Icc t0 T, HasDerivWithinAt x (v t (x t)) (Set.Icc t0 T) t)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∀ ε > 0, ∃ δ > 0, ∀ h, 0 < h ∧ h < δ →
    ∀ t ∈ Set.Icc t0 T, dist (x t) (euler_approx v t0 y0 h t) < ε := by
      -- Use `gronwallBound_le_eps_mul_C` with `\epsilon=1` to find a constant `C` such that `gronwallBound 0 K 1 \tau \le C` for all `\tau \in [0, T-t0]`.
      obtain ⟨C, hC⟩ : ∃ C > 0, ∀ t ∈ Set.Icc 0 (T - t0), gronwallBound 0 K.toNNReal 1 t ≤ C := by
        have := gronwallBound_le_eps_mul_C ( by positivity : ( 0 : ℝ ) ≤ K.toNNReal ) ( by linarith : ( 0 : ℝ ) ≤ T - t0 ) ( by positivity : ( 0 : ℝ ) ≤ 1 ) ; aesop;
      -- By definition of `euler_consistency_error`, for any $\epsilon > 0$, there exists $\delta > 0$ such that the consistency error is less than $\epsilon$ for $h < \delta$.
      intro ε hε
      obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ h ∈ Set.Ioo 0 δ, ∀ t ∈ Set.Icc t0 T, ‖euler_deriv v t0 y0 h t - v t (euler_approx v t0 y0 h t)‖ < ε / (2 * C) := by
        convert euler_consistency_error v t0 T y0 K h_time h_lip h_cont ( ε / ( 2 * C ) ) ( div_pos hε ( mul_pos zero_lt_two hC.1 ) ) using 1;
      use δ, hδ_pos;
      intro h hh t ht
      have h_dist : dist (x t) (euler_approx v t0 y0 h t) ≤ gronwallBound 0 K.toNNReal (ε / (2 * C)) (t - t0) := by
        apply_rules [ euler_dist_le ];
        · linarith;
        · exact fun t ht => le_of_lt ( hδ h hh t ht );
      -- By definition of `gronwallBound`, we have `gronwallBound 0 K.toNNReal (ε / (2 * C)) (t - t0) ≤ (ε / (2 * C)) * C`.
      have h_gronwall : gronwallBound 0 K.toNNReal (ε / (2 * C)) (t - t0) ≤ (ε / (2 * C)) * C := by
        convert mul_le_mul_of_nonneg_left ( hC.2 ( t - t0 ) ⟨ by linarith [ ht.1 ], by linarith [ ht.2 ] ⟩ ) ( div_nonneg hε.le ( mul_nonneg zero_le_two hC.1.le ) ) using 1 ; ring;
        unfold gronwallBound; ring;
        split_ifs <;> ring;
      exact h_dist.trans_lt ( h_gronwall.trans_lt ( by nlinarith [ mul_div_cancel₀ ε ( by linarith : ( 2 * C ) ≠ 0 ) ] ) )

/-
The explicit Euler method converges to the true solution of an ODE `x' = v(t, x)` on a finite interval `[t0, T]` as the step size `h` goes to 0, assuming `v` is Lipschitz and continuous, and the space is finite dimensional.
-/
theorem euler_method_convergence' {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E]
  (v : ℝ → E → E) (x : ℝ → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_init : x t0 = y0)
  (h_sol : ∀ t ∈ Set.Icc t0 T, HasDerivWithinAt x (v t (x t)) (Set.Icc t0 T) t)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∀ ε > 0, ∃ δ > 0, ∀ h, 0 < h ∧ h < δ →
    ∀ t ∈ Set.Icc t0 T, dist (x t) (euler_approx v t0 y0 h t) < ε := by
      exact?

/-
The explicit Euler method converges to the true solution of an ODE `x' = v(t, x)` on a finite interval `[t0, T]` as the step size `h` goes to 0, assuming `v` is Lipschitz and continuous, and the space is finite dimensional.
-/
theorem euler_method_convergence_final {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E]
  (v : ℝ → E → E) (x : ℝ → E) (t0 T : ℝ) (y0 : E) (K : ℝ)
  (h_time : t0 ≤ T)
  (h_init : x t0 = y0)
  (h_sol : ∀ t ∈ Set.Icc t0 T, HasDerivWithinAt x (v t (x t)) (Set.Icc t0 T) t)
  (h_lip : ∀ t ∈ Set.Icc t0 T, LipschitzWith (Real.toNNReal K) (v t))
  (h_cont : ContinuousOn (fun p : ℝ × E ↦ v p.1 p.2) (Set.Icc t0 T ×ˢ Set.univ)) :
  ∀ ε > 0, ∃ δ > 0, ∀ h, 0 < h ∧ h < δ →
    ∀ t ∈ Set.Icc t0 T, dist (x t) (euler_approx v t0 y0 h t) < ε := by
      exact?