/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e889c5ad-7d24-4277-999b-ac6bc14f4f75

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We implement the explicit Euler method for ODEs and prove its convergence.

Definitions:
- `eulerStep`: A single step of the Euler method.
- `eulerPoint`: The sequence of points generated by the Euler method.
- `eulerPath`: The piecewise linear interpolation of the Euler points.
- `eulerDeriv`: The right derivative of the Euler path.

Theorems:
- `eulerPath_grid_point`: The Euler path coincides with the Euler points at grid points.
- `eulerPath_continuous`: The Euler path is continuous.
- `eulerPath_hasDerivWithinAt`: The Euler path has the expected right derivative.
- `eulerPath_eq_on_Ico`: Explicit formula for the Euler path on intervals.
- `eulerDeriv_eq_on_Ico`: Explicit formula for the Euler derivative on intervals.
- `euler_dist_point_path`: Bound on the distance between the Euler point and the path.
- `euler_derivative_bound`: Local bound on the difference between the Euler derivative and the vector field.
- `euler_derivative_global_bound`: Global bound on the difference between the Euler derivative and the vector field.
- `euler_error_bound`: Error bound for the Euler method using Gronwall's inequality.
- `euler_convergence`: The Euler method converges to the true solution as the step size goes to zero.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/--
The Euler step for an ODE y' = v(t, y) with step size h is y_{n+1} = y_n + h * v(t_n, y_n).
-/
def eulerStep {E : Type*} [AddCommGroup E] [Module ℝ E] (v : ℝ → E → E) (h : ℝ) (t : ℝ) (y : E) : E :=
  y + h • v t y

/--
The n-th point in the Euler method approximation with step size h.
-/
def eulerPoint {E : Type*} [AddCommGroup E] [Module ℝ E] (v : ℝ → E → E) (h : ℝ) (t0 : ℝ) (y0 : E) : ℕ → E
| 0 => y0
| n + 1 => eulerStep v h (t0 + n * h) (eulerPoint v h t0 y0 n)

/--
The piecewise linear path interpolating the Euler method points.
-/
noncomputable def eulerPath {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (t0 : ℝ) (y0 : E) (t : ℝ) : E :=
  let n := Nat.floor ((t - t0) / h)
  let tn := t0 + n * h
  let yn := eulerPoint v h t0 y0 n
  yn + (t - tn) • v tn yn

/-
The Euler path coincides with the Euler points at the grid points.
-/
theorem eulerPath_grid_point {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) (n : ℕ) :
  eulerPath v h t0 y0 (t0 + n * h) = eulerPoint v h t0 y0 n := by
    unfold eulerPath;
    norm_num [ add_sub_cancel_left, h_pos.ne' ]

/--
The derivative of the Euler path (defined as the right derivative everywhere).
-/
noncomputable def eulerDeriv {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (t0 : ℝ) (y0 : E) (t : ℝ) : E :=
  let n := Nat.floor ((t - t0) / h)
  let tn := t0 + n * h
  let yn := eulerPoint v h t0 y0 n
  v tn yn

/-
The Euler path is continuous on [t0, ∞).
-/
theorem eulerPath_continuous {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) :
  ContinuousOn (eulerPath v h t0 y0) (Set.Ici t0) := by
    -- Fix an arbitrary $t \geq t_0$.
    have h_cont_at : ∀ (n : ℕ), ContinuousOn (fun t => eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n)) (Set.Icc (t0 + n * h) (t0 + (n + 1) * h)) := by
      fun_prop;
    have h_cont_at : ∀ (n : ℕ), ContinuousOn (fun t => eulerPath v h t0 y0 t) (Set.Icc (t0 + n * h) (t0 + (n + 1) * h)) := by
      intro n
      have h_eq : ∀ t ∈ Set.Ioo (t0 + n * h) (t0 + (n + 1) * h), eulerPath v h t0 y0 t = eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
        intro t ht
        simp [eulerPath];
        rw [ show ⌊ ( t - t0 ) / h⌋₊ = n by exact Nat.floor_eq_iff ( div_nonneg ( by nlinarith [ ht.1, ht.2 ] ) h_pos.le ) |>.2 ⟨ by nlinarith [ ht.1, ht.2, mul_div_cancel₀ ( t - t0 ) h_pos.ne' ], by nlinarith [ ht.1, ht.2, mul_div_cancel₀ ( t - t0 ) h_pos.ne' ] ⟩ ];
      have h_cont_at : ContinuousOn (fun t => eulerPath v h t0 y0 t) (Set.Ioo (t0 + n * h) (t0 + (n + 1) * h)) := by
        exact ContinuousOn.congr ( h_cont_at n |> ContinuousOn.mono <| Set.Ioo_subset_Icc_self ) h_eq;
      have h_cont_at : Filter.Tendsto (fun t => eulerPath v h t0 y0 t) (nhdsWithin (t0 + n * h) (Set.Ioi (t0 + n * h))) (nhds (eulerPath v h t0 y0 (t0 + n * h))) := by
        have h_cont_at : Filter.Tendsto (fun t => eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n)) (nhdsWithin (t0 + n * h) (Set.Ioi (t0 + n * h))) (nhds (eulerPoint v h t0 y0 n + (t0 + n * h - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n))) := by
          exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ ( by simp +decide ) );
        convert h_cont_at.congr' _ using 2;
        · simp +decide;
          exact eulerPath_grid_point v h h_pos t0 y0 n;
        · filter_upwards [ Ioo_mem_nhdsGT_of_mem ⟨ le_rfl, show t0 + n * h < t0 + ( n + 1 ) * h by linarith ⟩ ] with t ht using Eq.symm ( h_eq t ht );
      have h_cont_at : Filter.Tendsto (fun t => eulerPath v h t0 y0 t) (nhdsWithin (t0 + (n + 1) * h) (Set.Iio (t0 + (n + 1) * h))) (nhds (eulerPath v h t0 y0 (t0 + (n + 1) * h))) := by
        have h_cont_at : Filter.Tendsto (fun t => eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n)) (nhdsWithin (t0 + (n + 1) * h) (Set.Iio (t0 + (n + 1) * h))) (nhds (eulerPath v h t0 y0 (t0 + (n + 1) * h))) := by
          have h_cont_at : Filter.Tendsto (fun t => eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n)) (nhdsWithin (t0 + (n + 1) * h) (Set.Iio (t0 + (n + 1) * h))) (nhds (eulerPoint v h t0 y0 n + ((t0 + (n + 1) * h) - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n))) := by
            exact tendsto_const_nhds.add ( Filter.Tendsto.smul ( continuousWithinAt_id.sub continuousWithinAt_const ) tendsto_const_nhds );
          convert h_cont_at using 2 ; ring_nf!;
          convert eulerPath_grid_point v h h_pos t0 y0 ( n + 1 ) using 1 ; ring_nf!;
          push_cast; ring_nf;
        refine' h_cont_at.congr' _;
        filter_upwards [ Ioo_mem_nhdsLT ( show t0 + n * h < t0 + ( n + 1 ) * h by linarith ) ] with t ht using Eq.symm ( h_eq t ht );
      intro t ht;
      cases eq_or_lt_of_le ht.1 <;> cases eq_or_lt_of_le ht.2 <;> simp_all +decide [ ContinuousWithinAt ];
      · rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
        intro ε hε; rcases ‹∀ ε > 0, ∃ δ > 0, ∀ ⦃x : ℝ⦄, x ∈ Set.Ioi t → Dist.dist x t < δ → Dist.dist ( eulerPath v h t0 y0 x ) ( eulerPath v h t0 y0 t ) < ε› ε hε with ⟨ δ, hδ, H ⟩ ; use δ, hδ; intro x hx₁ hx₂; cases lt_or_eq_of_le hx₁.out <;> aesop;
      · rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
        intro ε ε_pos; rcases h_cont_at ε ε_pos with ⟨ δ, δ_pos, H ⟩ ; exact ⟨ δ, δ_pos, fun x hx₁ hx₂ => if hx₃ : x = t0 + ( n + 1 ) * h then by simpa [ hx₃ ] else H ( lt_of_le_of_ne hx₁ hx₃ ) hx₂ ⟩ ;
      · convert ‹ContinuousOn ( fun t => eulerPath v h t0 y0 t ) ( Set.Ioo ( t0 + n * h ) ( t0 + ( n + 1 ) * h ) ) ›.continuousAt ( Ioo_mem_nhds ‹_› ‹_› ) |> fun h => h.mono_left inf_le_left using 1 ; aesop;
    intro t ht;
    by_cases h_cases : ∃ n : ℕ, t = t0 + n * h;
    · obtain ⟨ n, rfl ⟩ := h_cases;
      have h_cont_at : ContinuousWithinAt (eulerPath v h t0 y0) (Set.Icc (t0 + n * h) (t0 + (n + 1) * h)) (t0 + n * h) := by
        exact h_cont_at n |> ContinuousOn.continuousWithinAt <| Set.left_mem_Icc.mpr <| by nlinarith;
      have h_cont_at : ContinuousWithinAt (eulerPath v h t0 y0) (Set.Icc (t0 + (n - 1) * h) (t0 + n * h)) (t0 + n * h) := by
        by_cases hn : n = 0;
        · simp [hn];
          refine' ContinuousWithinAt.congr _ _ _;
          use fun t => y0 + ( t - t0 ) • v t0 y0;
          · exact Continuous.continuousWithinAt ( by continuity );
          · intro y hy; unfold eulerPath; simp +decide [ Nat.floor_eq_zero.mpr ( show ( y - t0 ) / h < 1 by rw [ div_lt_iff₀ h_pos ] ; linarith [ hy.1, hy.2 ] ) ] ;
            rfl;
          · simp +decide [ eulerPath ];
            rfl;
        · have h_cont_at : ContinuousOn (fun t => eulerPath v h t0 y0 t) (Set.Icc (t0 + (n - 1) * h) (t0 + n * h)) := by
            convert ‹∀ n : ℕ, ContinuousOn ( fun t => eulerPath v h t0 y0 t ) ( Set.Icc ( t0 + n * h ) ( t0 + ( n + 1 ) * h ) ) › ( n - 1 ) using 1 ; cases n <;> aesop;
          exact h_cont_at.continuousWithinAt ( Set.right_mem_Icc.mpr ( by nlinarith ) );
      have h_cont_at : ContinuousWithinAt (eulerPath v h t0 y0) (Set.Icc (t0 + (n - 1) * h) (t0 + (n + 1) * h)) (t0 + n * h) := by
        rw [ Metric.continuousWithinAt_iff ] at *;
        intro ε hε; rcases h_cont_at ε hε with ⟨ δ₁, hδ₁, H₁ ⟩ ; rcases ‹∀ ε > 0, ∃ δ > 0, ∀ ⦃x : ℝ⦄, x ∈ Set.Icc ( t0 + ( n : ℝ ) * h ) ( t0 + ( n + 1 ) * h ) → Dist.dist x ( t0 + ( n : ℝ ) * h ) < δ → Dist.dist ( eulerPath v h t0 y0 x ) ( eulerPath v h t0 y0 ( t0 + ( n : ℝ ) * h ) ) < ε› ε hε with ⟨ δ₂, hδ₂, H₂ ⟩ ; refine' ⟨ Min.min δ₁ δ₂, lt_min hδ₁ hδ₂, fun x hx₁ hx₂ => _ ⟩ ; cases le_total x ( t0 + ( n : ℝ ) * h ) <;> simp_all +decide ;
      have h_cont_at : ContinuousWithinAt (eulerPath v h t0 y0) (Set.Icc (t0 + (n - 1) * h) (t0 + (n + 1) * h) ∩ Set.Ici t0) (t0 + n * h) := by
        exact h_cont_at.mono ( Set.inter_subset_left );
      refine' h_cont_at.mono_of_mem_nhdsWithin _;
      rw [ mem_nhdsWithin_iff_exists_mem_nhds_inter ];
      exact ⟨ Set.Icc ( t0 + h * ( n - 1 ) ) ( t0 + h * ( n + 1 ) ), Icc_mem_nhds ( by nlinarith ) ( by nlinarith ), fun x hx => ⟨ ⟨ by linarith [ hx.1.1 ], by linarith [ hx.1.2 ] ⟩, hx.2 ⟩ ⟩;
    · -- Since $t$ is not of the form $t_0 + n * h$, there exists some $n$ such that $t \in (t0 + n * h, t0 + (n + 1) * h)$.
      obtain ⟨n, hn⟩ : ∃ n : ℕ, t ∈ Set.Ioo (t0 + n * h) (t0 + (n + 1) * h) := by
        use Nat.floor ((t - t0) / h);
        exact ⟨ lt_of_le_of_ne ( by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht ) h_pos.le ), mul_div_cancel₀ ( t - t0 ) h_pos.ne' ] ) fun h => h_cases ⟨ _, h.symm ⟩, by nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) h_pos.ne' ] ⟩;
      exact ContinuousAt.continuousWithinAt ( h_cont_at n |> ContinuousOn.continuousAt <| Icc_mem_nhds hn.1 hn.2 )

/-
The Euler path has the expected right derivative everywhere.
-/
theorem eulerPath_hasDerivWithinAt {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) (t : ℝ) (ht : t0 ≤ t) :
  HasDerivWithinAt (eulerPath v h t0 y0) (eulerDeriv v h t0 y0 t) (Set.Ici t) t := by
    -- By definition of $eulerPath$, we know that its right derivative at $t$ is given by $eulerDeriv v h t0 y0 t$.
    have h_right_deriv : ∀ t ≥ t0, HasDerivWithinAt (eulerPath v h t0 y0) (eulerDeriv v h t0 y0 t) (Set.Ioi t) t := by
      intro t ht
      have h_right_deriv : ∀ᶠ t' in nhdsWithin t (Set.Ioi t), eulerPath v h t0 y0 t' = eulerPoint v h t0 y0 (Nat.floor ((t - t0) / h)) + (t' - (t0 + Nat.floor ((t - t0) / h) * h)) • v (t0 + Nat.floor ((t - t0) / h) * h) (eulerPoint v h t0 y0 (Nat.floor ((t - t0) / h))) := by
        refine' eventually_nhdsWithin_iff.mpr _;
        filter_upwards [ Ioo_mem_nhds ( show t > t0 - h by linarith ) ( show t < t0 + h * ( ⌊ ( t - t0 ) / h⌋₊ + 1 ) by nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) h_pos.ne' ] ) ] with x hx hx' ; simp_all +decide [ mul_comm h ];
        rw [ eulerPath ];
        rw [ show ⌊ ( x - t0 ) / h⌋₊ = ⌊ ( t - t0 ) / h⌋₊ from Nat.floor_eq_iff ( div_nonneg ( by linarith ) h_pos.le ) |>.2 ⟨ by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( by linarith ) h_pos.le ), mul_div_cancel₀ ( t - t0 ) h_pos.ne', mul_div_cancel₀ ( x - t0 ) h_pos.ne' ], by nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) h_pos.ne', mul_div_cancel₀ ( x - t0 ) h_pos.ne' ] ⟩ ];
      rw [ Filter.EventuallyEq.hasDerivWithinAt_iff ] at *;
      any_goals tauto;
      rw [ hasDerivWithinAt_iff_tendsto ];
      simp +decide [ ← sub_smul, eulerDeriv ];
    exact hasDerivWithinAt_Ioi_iff_Ici.mp (h_right_deriv t ht)

/-
On the interval [t_n, t_{n+1}), the Euler path is given by the affine function starting at y_n with slope v(t_n, y_n).
-/
theorem eulerPath_eq_on_Ico {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) (n : ℕ)
  (t : ℝ) (ht : t ∈ Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  eulerPath v h t0 y0 t = eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
    -- By definition of eulerPath, we know that for t in [t_n, t_{n+1}), eulerPath v h t0 y0 t is equal to eulerPoint v h t0 y0 n + (t - t_n) • v(t_n, eulerPoint v h t0 y0 n).
    have h_eulerPath_def : ∀ t ∈ Set.Ico (t0 + n * h) (t0 + (n + 1) * h), eulerPath v h t0 y0 t = eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
      intro t ht
      have h_floor : Nat.floor ((t - t0) / h) = n := by
        rw [ Nat.floor_eq_iff ];
        · exact ⟨ by rw [ le_div_iff₀ h_pos ] ; linarith [ ht.1 ], by rw [ div_lt_iff₀ h_pos ] ; linarith [ ht.2 ] ⟩;
        · exact div_nonneg ( by nlinarith [ ht.1 ] ) h_pos.le;
      -- By definition of eulerPath, we know that for t in [t_n, t_{n+1}), eulerPath v h t0 y0 t is equal to eulerPoint v h t0 y0 n + (t - t_n) • v(t_n, eulerPoint v h t0 y0 n) because the floor of (t - t0)/h is n.
      simp [eulerPath, h_floor];
    exact h_eulerPath_def t ht

/-
On the interval [t_n, t_{n+1}), the Euler derivative is constant and equal to v(t_n, y_n).
-/
theorem eulerDeriv_eq_on_Ico {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) (n : ℕ)
  (t : ℝ) (ht : t ∈ Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  eulerDeriv v h t0 y0 t = v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
    -- By definition of Nat.floor, we have Nat.floor ((t - t0) / h) = n since t is in the interval [t0 + n*h, t0 + (n+1)*h).
    have h_floor : Nat.floor ((t - t0) / h) = n := by
      exact Nat.floor_eq_iff ( div_nonneg ( by nlinarith [ ht.1 ] ) h_pos.le ) |>.2 ⟨ by rw [ le_div_iff₀ h_pos ] ; linarith [ ht.1 ], by rw [ div_lt_iff₀ h_pos ] ; linarith [ ht.2 ] ⟩;
    unfold eulerDeriv; aesop;

/-
The distance between the Euler point and the Euler path on the interval [t_n, t_{n+1}) is bounded by h * M.
-/
theorem euler_dist_point_path {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) (n : ℕ)
  (M : ℝ) (v_bound : ∀ t y, ‖v t y‖ ≤ M)
  (t : ℝ) (ht : t ∈ Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  dist (eulerPoint v h t0 y0 n) (eulerPath v h t0 y0 t) ≤ h * M := by
    -- By definition of $eulerPath$, we have $eulerPath v h t0 y0 t = eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n)$.
    have h_eulerPath : eulerPath v h t0 y0 t = eulerPoint v h t0 y0 n + (t - (t0 + n * h)) • v (t0 + n * h) (eulerPoint v h t0 y0 n) := by
      convert eulerPath_eq_on_Ico v h h_pos t0 y0 n t ht using 1;
    rw [ h_eulerPath, dist_eq_norm ];
    simp +decide [ norm_smul, abs_of_nonneg ( sub_nonneg.2 ht.1 ) ];
    exact mul_le_mul ( by nlinarith [ ht.1, ht.2 ] ) ( v_bound _ _ ) ( by positivity ) ( by positivity )

/-
Bound on the difference between the Euler derivative and the vector field at the Euler path.
-/
theorem euler_derivative_bound {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) (n : ℕ)
  (K L : NNReal) (M : ℝ)
  (hv : ∀ t, LipschitzWith K (v t))
  (hv_t : ∀ y, LipschitzWith L (fun t => v t y))
  (v_bound : ∀ t y, ‖v t y‖ ≤ M)
  (t : ℝ) (ht : t ∈ Set.Ico (t0 + n * h) (t0 + (n + 1) * h)) :
  dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t)) ≤ h * (L + K * M) := by
    -- Using the Lipschitz properties and the bounds we established, we can bound the distances.
    have h1 : dist (v (t0 + n * h) (eulerPoint v h t0 y0 n)) (v t (eulerPoint v h t0 y0 n)) ≤ L * (t - (t0 + n * h)) := by
      have := hv_t ( eulerPoint v h t0 y0 n );
      simpa only [ dist_eq_norm, norm_sub_rev ] using this.dist_le_mul ( t0 + n * h ) t |> le_trans <| by rw [ dist_eq_norm ] ; rw [ Real.norm_of_nonpos ] <;> linarith [ ht.1, ht.2 ] ;
    have h2 : dist (v t (eulerPoint v h t0 y0 n)) (v t (eulerPath v h t0 y0 t)) ≤ K * (h * M) := by
      have h2 : dist (eulerPoint v h t0 y0 n) (eulerPath v h t0 y0 t) ≤ h * M := by
        convert euler_dist_point_path v h h_pos t0 y0 n M v_bound t ht using 1;
      exact le_trans ( hv t |> LipschitzWith.dist_le_mul |> fun h => h _ _ ) ( mul_le_mul_of_nonneg_left h2 <| NNReal.coe_nonneg _ );
    -- Using the triangle inequality, we can combine these bounds.
    have h_combined : dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t)) ≤ (L : ℝ) * (t - (t0 + n * h)) + (K : ℝ) * (h * M) := by
      convert dist_triangle _ _ _ |> le_trans <| add_le_add h1 h2 using 1;
      rw [ eulerDeriv_eq_on_Ico v h h_pos t0 y0 n t ht ];
    exact h_combined.trans ( by nlinarith [ ht.1, ht.2, show ( 0 : ℝ ) ≤ L by positivity, show ( 0 : ℝ ) ≤ K * M by exact mul_nonneg ( NNReal.coe_nonneg _ ) ( show ( 0 : ℝ ) ≤ M by exact le_trans ( norm_nonneg _ ) ( v_bound t0 y0 ) ) ] )

/-
Global bound on the difference between the Euler derivative and the vector field.
-/
theorem euler_derivative_global_bound {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E)
  (K L : NNReal) (M : ℝ)
  (hv : ∀ t, LipschitzWith K (v t))
  (hv_t : ∀ y, LipschitzWith L (fun t => v t y))
  (v_bound : ∀ t y, ‖v t y‖ ≤ M)
  (t : ℝ) (ht : t0 ≤ t) :
  dist (eulerDeriv v h t0 y0 t) (v t (eulerPath v h t0 y0 t)) ≤ h * (L + K * M) := by
    convert euler_derivative_bound v h h_pos t0 y0 ( Nat.floor ( ( t - t0 ) / h ) ) K L M hv hv_t v_bound t _ using 2;
    exact ⟨ by nlinarith [ Nat.floor_le ( show 0 ≤ ( t - t0 ) / h by exact div_nonneg ( sub_nonneg.mpr ht ) h_pos.le ), mul_div_cancel₀ ( t - t0 ) h_pos.ne' ], by nlinarith [ Nat.lt_floor_add_one ( ( t - t0 ) / h ), mul_div_cancel₀ ( t - t0 ) h_pos.ne' ] ⟩

/-
Error bound for the Euler method using Gronwall's inequality.
-/
theorem euler_error_bound {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (h : ℝ) (h_pos : 0 < h) (t0 : ℝ) (y0 : E) (T : ℝ)
  (K L : NNReal) (M : ℝ)
  (hv : ∀ t, LipschitzWith K (v t))
  (hv_t : ∀ y, LipschitzWith L (fun t => v t y))
  (v_bound : ∀ t y, ‖v t y‖ ≤ M)
  (sol : ℝ → E)
  (sol_cont : ContinuousOn sol (Set.Icc t0 T))
  (sol_deriv : ∀ t ∈ Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
  (sol_init : sol t0 = y0) :
  ∀ t ∈ Set.Icc t0 T, dist (eulerPath v h t0 y0 t) (sol t) ≤ gronwallBound 0 K (h * (L + K * M)) (t - t0) := by
    intro t ht;
    convert dist_le_of_approx_trajectories_ODE hv _ _ _ _ _ _ _ _ _ using 1;
    any_goals exact ht;
    rotate_left 1;
    exact fun t => eulerDeriv v h t0 y0 t;
    exact fun t => v t ( sol t );
    exact h * ( L + K * M );
    exact 0;
    exact 0;
    exact ContinuousOn.mono ( eulerPath_continuous v h h_pos t0 y0 ) ( Set.Icc_subset_Ici_self );
    exact fun t ht => eulerPath_hasDerivWithinAt v h h_pos t0 y0 t ht.1;
    exact fun t ht => euler_derivative_global_bound v h h_pos t0 y0 K L M hv hv_t v_bound t ht.1;
    · exact sol_cont;
    · exact sol_deriv;
    · simp +decide [ dist_self ];
    · simp +decide [ sol_init ];
      convert eulerPath_grid_point v h h_pos t0 y0 0;
      norm_num;
    · rw [ add_zero ]

/-
Convergence of the Euler method to the true solution as the time step goes to zero.
-/
theorem euler_convergence {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (v : ℝ → E → E) (t0 : ℝ) (y0 : E) (T : ℝ)
  (K L : NNReal) (M : ℝ)
  (hv : ∀ t, LipschitzWith K (v t))
  (hv_t : ∀ y, LipschitzWith L (fun t => v t y))
  (v_bound : ∀ t y, ‖v t y‖ ≤ M)
  (sol : ℝ → E)
  (sol_cont : ContinuousOn sol (Set.Icc t0 T))
  (sol_deriv : ∀ t ∈ Set.Ico t0 T, HasDerivWithinAt sol (v t (sol t)) (Set.Ici t) t)
  (sol_init : sol t0 = y0) :
  ∀ t ∈ Set.Icc t0 T, Filter.Tendsto (fun h => eulerPath v h t0 y0 t) (nhdsWithin 0 (Set.Ioi 0)) (nhds (sol t)) := by
    intro t ht;
    -- By the error bound, we have that the distance between the Euler path and the solution is bounded by gronwallBound 0 K (h * (L + K * M)) (t - t0).
    have h_error_bound : ∀ h > 0, dist (eulerPath v h t0 y0 t) (sol t) ≤ gronwallBound 0 K (h * (L + K * M)) (t - t0) := by
      exact fun h a ↦
        euler_error_bound v h a t0 y0 T K L M hv hv_t v_bound sol sol_cont sol_deriv sol_init t
          ht;
    -- Since $\epsilon \mapsto \text{gronwallBound } 0\ K\ \epsilon\ (t - t_0)$ is continuous at 0, and takes value 0 at 0, $g(h) \to 0$.
    have h_gronwall_zero : Filter.Tendsto (fun h => gronwallBound 0 K (h * (L + K * M)) (t - t0)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      have h_gronwall_zero : Continuous (fun ε : ℝ => gronwallBound 0 (K : ℝ) ε (t - t0)) := by
        exact gronwallBound_continuous_ε _ _ _;
      convert h_gronwall_zero.continuousWithinAt.tendsto.comp ( show Filter.Tendsto ( fun h : ℝ => h * ( L + K * M ) ) ( nhdsWithin 0 ( Set.Ioi 0 ) ) ( nhdsWithin 0 ( Set.Ici 0 ) ) from ?_ ) using 2;
      · exact Eq.symm ( gronwallBound_ε0_δ0 _ _ );
      · refine' Filter.Tendsto.inf _ _ <;> norm_num;
        · exact Continuous.tendsto' ( by continuity ) _ _ ( by simp +decide );
        · exact fun x hx => mul_nonneg hx.le ( add_nonneg ( NNReal.coe_nonneg _ ) ( mul_nonneg ( NNReal.coe_nonneg _ ) ( show 0 ≤ M by exact le_trans ( norm_nonneg _ ) ( v_bound t0 y0 ) ) ) );
    exact tendsto_iff_dist_tendsto_zero.mpr ( squeeze_zero_norm' ( Filter.eventually_of_mem self_mem_nhdsWithin fun x hx => by simpa using h_error_bound x hx ) h_gronwall_zero )
